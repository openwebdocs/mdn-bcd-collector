#
# mdn-bcd-collector: custom-tests.yaml
# Custom test code to override auto-generated test code
#
# ¬© Gooborg Studios, Mozilla Corporation, Google LLC, Apple Inc
# See the LICENSE file for copyright details
#

# See docs/custom-tests.md for instructions on how to modify this file

# Reusable resources
__resources:
  audio-blip:
    type: audio
    src:
      - /media/blip.mp3
      - /media/blip.ogg
  video-blank:
    type: video
    src:
      - /media/blank.mp4
      - /media/blank.webm
    subtitles:
      - label: English
        lang: en
        src: /media/subtitles.vtt
  image-black:
    type: image
    src: /media/black.png
    alt: A blank image
  audioContext:
    type: instance
    src: |-
      var constructor = window.AudioContext || window.webkitAudioContext;
      if (!constructor) {
        return null;
      }
      return new constructor();
  createStyleSheet:
    type: instance
    src: |-
      return function(css) {
        var el = document.createElement('style');
        el.innerHTML = css;
        (document.head || document.body).appendChild(el);
        el.sheet.disabled = true;
        return el.sheet;
      }
  cryptoKey:
    type: instance
    src: |-
      if (!('crypto' in self) || !crypto) {
        return null;
      };
      var subtle = crypto.subtle || crypto.webkitSubtle;
      if (!subtle) {
        return null;
      };
      return subtle.generateKey({
        name: 'RSA-OAEP',
        modulusLength: 4096,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: { name: 'SHA-256' }
      }, true, ['encrypt', 'decrypt']).then(function(pair) {
        return pair.publicKey;
      });
  mediaStream:
    type: instance
    callback: true
    dependencies:
      - audioContext
    src: |-
      // First, we'll try creating a dummy stream
      var stream;

      if ('MediaStream' in self) {
        try {
          var stream = new MediaStream();
        } catch(e) {
          // If creating the MediaStream fails, continue
        }
      }

      if (
        stream &&
        reusableInstances.audioContext &&
        'createMediaStreamDestination' in reusableInstances.audioContext &&
        'captureStream' in HTMLCanvasElement.prototype
      ) {
        // Create the audio noise stream
        var oscillator = reusableInstances.audioContext.createOscillator();
        var dst = oscillator.connect(reusableInstances.audioContext.createMediaStreamDestination());
        oscillator.start();
        var audioTrack = dst.stream.getAudioTracks()[0];
        stream.addTrack(audioTrack);
        bcd.addCleanup(function() {audioTrack.stop()});

        // Create the video noise stream
        var canvas = document.createElement("canvas");
        canvas.width = 640;
        canvas.height = 480;
        var ctx = canvas.getContext('2d');
        var videoStream = canvas.captureStream(60);
        var count = 0;
        var interval = setInterval(function() {
          ctx.fillStyle = `rgb(${count%255}, ${count*count%255}, ${count%255})`;
          count += 1;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          // Add some bouncing boxes in contrast color to add a little more noise.
          var contrast = count + 128;
          ctx.fillStyle = `rgb(${contrast%255}, ${contrast*contrast%255}, ${contrast%255})`;
          var xpos = count % (canvas.width - 20);
          var ypos = count % (canvas.height - 20);
          ctx.fillRect(xpos, ypos, xpos + 20, ypos + 20);
          var xpos2 = (count + canvas.width / 2) % (canvas.width - 20);
          var ypos2 = (count + canvas.height / 2) % (canvas.height - 20);
          ctx.fillRect(xpos2, ypos2, xpos2 + 20, ypos2 + 20);
        }, 50);
        var videoTrack = videoStream.getVideoTracks()[0];
        stream.addTrack(videoTrack);
        bcd.addCleanup(function() {videoTrack.stop()});

        // Return the stream
        callback(stream);
        return;
      }

      // If we couldn't create a dummy stream, we'll use the camera and mic instead
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices.getUserMedia({audio: true}).then(callback, fail);
      } else if (navigator.getUserMedia) {
        navigator.getUserMedia({audio: true}, callback, fail);
      } else if (navigator.mozGetUserMedia) {
        navigator.mozGetUserMedia({audio: true}, callback, fail);
      } else if (navigator.webkitGetUserMedia) {
        navigator.webkitGetUserMedia({audio: true}, callback, fail);
      } else {
        fail('navigator(.mediaDevices).(moz/webkit)getUserMedia is not defined');
      }
  offlineAudioContext:
    type: instance
    src: |-
      var constructor = window.OfflineAudioContext || window.webkitOfflineAudioContext;
      if (!constructor) {
        return null;
      }
      return new constructor(2,44100*40,44100);
  rtcStats:
    type: instance
    callback: true
    dependencies:
      - mediaStream
    src: |-
      // Most of this code has loosely been taken from https://wpt.live/webrtc/RTCPeerConnection-mandatory-getStats.https.html

      /* Firefox briefly defines RTCPeerConnection in older versions, but it is not a valid constructor until later versions. */
      var peerConnectionConstructor = window.mozRTCPeerConnection || window.RTCPeerConnection || window.webkitRTCPeerConnection;
      if (!peerConnectionConstructor) {
        callback(false);
        return;
      };

      // Create RTC peer connections
      var rpc1 = new peerConnectionConstructor({iceServers: []});
      var rpc2 = new peerConnectionConstructor({iceServers: []});

      // Create data channels
      var dc1 = rpc1.createDataChannel("dummy", {negotiated: true, id: 0});
      var dc2 = rpc2.createDataChannel("dummy", {negotiated: true, id: 0});

      if (!('addTrack' in rpc1)) {
        // XXX Handle this somehow
        fail('RTCPeerConnection.addTrack must be defined');
        return;
      }

      if (!('mediaStream' in reusableInstances)) {
        // XXX Handle mediaStream not being defined
        fail('Media stream must be defined');
        return;
      }

      // Add stream to RTC connections
      var audioTrack = reusableInstances.mediaStream.getAudioTracks()[0];
      var videoTrack = reusableInstances.mediaStream.getVideoTracks()[0];
      rpc1.addTrack(audioTrack, reusableInstances.mediaStream);
      rpc1.addTrack(videoTrack, reusableInstances.mediaStream);
      rpc2.addTrack(audioTrack, reusableInstances.mediaStream);
      rpc2.addTrack(videoTrack, reusableInstances.mediaStream);

      // Perform ice candidate exchange
      function doExchange(localPc, remotePc) {
        localPc.addEventListener('icecandidate', function(event) {
          // Guard against already closed peerconnection to
          // avoid unrelated exceptions.
          if (remotePc.signalingState !== 'closed') {
            remotePc.addIceCandidate(event.candidate).catch(function() {});
          }
        });
      }
      doExchange(rpc1, rpc2);
      doExchange(rpc2, rpc1);

      // Remove transport-cc related lines from SDP
      function removeTwcc(sdp) {
        var lines = sdp.split('\r\n');
        var builder = [];
        for (var i = 0; i < lines.length; i++) {
          if (/^a=extmap:.*transport-wide-cc-extensions.*$/.test(lines[i])) {
            continue;
          }
          if (/^a=rtcp-fb:.*transport-cc.*$/.test(lines[i])) {
            continue;
          }
          builder.push(lines[i]);
        }
        return builder.join('\r\n');
      }

      // Exchange offer and answer between two peer connections
      function exchangeOfferAnswer(localPc, remotePc) {
        return localPc.createOffer().then(function(offer) {
          var newOffer = {
            type: offer.type,
            sdp: removeTwcc(offer.sdp)
          };
          return localPc.setLocalDescription(newOffer);
        }).then(function() {
          return remotePc.setRemoteDescription(localPc.localDescription);
        }).then(function() {
          return remotePc.createAnswer();
        }).then(function(answer) {
          return Promise.all([
            localPc.setRemoteDescription(answer),
            remotePc.setLocalDescription(answer)
          ]);
        })
      };

      function getStats(pc, statsCallback) {
        var statsPromise;
        try {
          statsPromise = pc.getStats();
        } catch(e) {
          // If we run into an error, it's probably not a promise
        }

        if (statsPromise) {
          statsPromise.then(statsCallback).catch(fail);
        } else {
          try {
            pc.getStats(statsCallback, fail);
          } catch(e) {
            fail(e);
          }
        }
      }

      exchangeOfferAnswer(rpc1, rpc2).then(function() {
        return exchangeOfferAnswer(rpc2, rpc1);
      }).then(function() {
        setTimeout(function() {
          // Some stats are loaded later than others. Wait a bit after creating
          // the connection, then call getStats. After that, call getStats once more
          // since some stats will be created after the first call to getStats.

          // Obtain stats from both peer connections and combine them, as each
          // connection has different stats types
          getStats(rpc1, function() {
            getStats(rpc2, function() {
              setTimeout(function() {
                getStats(rpc1, function(stats1) {
                  getStats(rpc2, function(stats2) {
                    var stats = new Map([...stats1, ...stats2]);
                    callback(stats);
                  });
                });
              }, 3000);
            });
          });
        }, 1000);

        bcd.addCleanup(function() {
          rpc1.close();
          rpc2.close();
          if (audioTrack) {
            audioTrack.stop();
          }
          if (videoTrack) {
            videoTrack.stop();
          }
        });
      });
  speechRecognition:
    type: instance
    src: |-
      var constructor = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!constructor) {
        return null;
      }
      return new constructor();
  webGL:
    type: instance
    src: |-
      var canvas = document.createElement('canvas');
      if (!canvas) {
        return null;
      };
      return canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  webGL1:
    type: instance
    src: |-
      var canvas = document.createElement('canvas');
      if (!canvas) {
        return null;
      };
      return canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  webGL2:
    type: instance
    src: |-
      var canvas = document.createElement('canvas');
      if (!canvas) {
        return null;
      };
      return canvas.getContext('webgl2');

# Features defined here also need to be in @webref/idl or custom/idl/.
api:
  _globals:
    crypto: return !!self.crypto;
  AbortSignal:
    abort_static:
      __additional:
        reason_parameter: |-
          if (!('AbortSignal' in self)) {
            return {result: false, message: 'AbortSignal is not defined'};
          }
          if (!('abort' in AbortSignal)) {
            return {result: false, message: 'AbortSignal.abort is undefined'}
          }
          var instance = AbortSignal.abort('Foo bar');
          return instance.reason === 'Foo bar';
  Attr:
    __base: |-
      var el = document.createElement('b');
      el.setAttribute('data-foo', 'bar');
      var instance;
      if ('getAttributeNode' in el) {
        instance = el.getAttributeNode('data-foo');
      } else if ('attributes' in el) {
        instance = el.attributes.item(0);
      }
  ANGLE_instanced_arrays:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('ANGLE_instanced_arrays');
    __test: return !!instance;
  AnalyserNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createAnalyser' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createAnalyser is not defined'};
      }
      var instance = reusableInstances.audioContext.createAnalyser();
  AnimationEvent:
    __base: |-
      var instance;
      try {
        instance = new AnimationEvent('animationend');
      } catch(e) {
        try {
          instance = document.createEvent('AnimationEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  ApplicationCache:
    __base: var instance = window.applicationCache;
  AudioBuffer:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.createBuffer(2, reusableInstances.audioContext.sampleRate * 3, reusableInstances.audioContext.sampleRate);
  AudioBufferSourceNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createBufferSource' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createBufferSource is not defined'};
      }
      var instance = reusableInstances.audioContext.createBufferSource();
  AudioContext:
    __resources:
      - audioContext
    __base: var instance = reusableInstances.audioContext;
    __test: return 'AudioContext' in self;
    AudioContext:
      __additional:
        options_latencyHint_parameter: return bcd.testOptionParam(window.AudioContext || window.webkitAudioContext, 'constructor', 'latencyHint', 'playback');
        options_sampleRate_parameter: return bcd.testOptionParam(window.AudioContext || window.webkitAudioContext, 'constructor', 'sampleRate', '44100');
        options_sinkId_parameter: return bcd.testOptionParam(window.AudioContext || window.webkitAudioContext, 'constructor', 'sinkId', '');
  AudioDestinationNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.destination;
  AudioListener:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var instance = reusableInstances.audioContext.listener;
  AudioNode:
    __resources:
      - audioContext
    __base: |-
      <%api.AnalyserNode:instance%>
    disconnect:
      __additional:
        destination_parameter: |-
          // XXX testOptionParam doesn't work here
          return {result: null, message: 'Detection methods are unsupported for this method'};

          <%api.AnalyserNode:node2%>
          instance.connect(node2);
          return bcd.testOptionParam(instance, 'disconnect', null, node2);
        output_parameter: |-
          // XXX testOptionParam doesn't work here
          return {result: null, message: 'Detection methods are unsupported for this method'};

          <%api.AnalyserNode:node2%>
          instance.connect(node2);
          function disconnect(output) {
            instance.disconnect(node2, output);
          }
          return bcd.testOptionParam(disconnect, null, null, 0);
        input_parameter: |-
          // XXX testOptionParam doesn't work here
          return {result: null, message: 'Detection methods are unsupported for this method'};

          <%api.AnalyserNode:node2%>
          instance.connect(node2);
          function disconnect(input) {
            instance.disconnect(node2, 0, input);
          }
          return bcd.testOptionParam(disconnect, null, null, 0);
  AudioParam:
    __resources:
      - audioContext
    __base: |-
      <%api.BiquadFilterNode:biquadFilterNode%>
      var instance = biquadFilterNode.gain;
  AudioProcessingEvent:
    __base: |-
      var instance;
      var inputBuffer = new AudioBuffer({length: 1, sampleRate: 30000});
      var outputBuffer = new AudioBuffer({length: 1, sampleRate: 30000});
      try {
        instance = new AudioProcessingEvent('audioprocess', {inputBuffer: inputBuffer, outputBuffer: outputBuffer, playbackTime: 0});
      } catch(e) {
        try {
          instance = document.createEvent('AudioProcessingEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  AudioScheduledSourceNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createBufferSource' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createBufferSource is not defined'};
      }
      var instance = reusableInstances.audioContext.createBufferSource();
    __test: return 'AudioScheduledSourceNode' in self;
  AudioTrack:
    __resources:
      - audio-blip
    __base: <%api.AudioTrackList:audioTracks%> var instance = audioTracks[0];
  AudioTrackList:
    __resources:
      - audio-blip
    __base: |-
      var el = document.getElementById('resource-audio-blip');
      var instance = el.audioTracks;
  AudioWorkletNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if
      (!reusableInstances.audioContext.audioWorklet) {
        return {result: false, message: 'Audio worklets are not available'};
      }
      var promise = reusableInstances.audioContext.audioWorklet.addModule('/resources/custom-tests/api/AudioWorkletNode/WhiteNoiseProcessor.js').then(
        function() {
          return new AudioWorkletNode(reusableInstances.audioContext, 'white-noise-processor')
        }
      );
      promise.then(function() {});
  BarProp:
    __base: var instance = window.toolbar;
  BaseAudioContext:
    __resources:
      - audioContext
    __base: var instance = reusableInstances.audioContext;
    __test: return 'BaseAudioContext' in self;
    createPeriodicWave:
      __additional:
        constraints_disableNormalization_parameter: |-
          if (!(instance && instance.createPeriodicWave)) {
            return {result: false, message: 'instance.createPeriodicWave is not defined'};
          }
          function create(constraints) {
            var real = new Float32Array(2);
            var imag = new Float32Array(2);

            real[0] = 0;
            real[1] = 1;
            imag[0] = 0;
            imag[1] = 0;

            instance.createPeriodicWave(real, imag, constraints);
          }
          return bcd.testOptionParam(create, null, 'disableNormalization', true);
    decodeAudioData:
      __additional:
        returns_promise: |-
          <%api.BaseAudioContext:ctx%>
          if (!(instance && instance.decodeAudioData)) {
            return {result: false, message: 'instance.decodeAudioData is not defined'};
          }
          var value = instance.decodeAudioData(new ArrayBuffer());
          return 'then' in value;
  BatteryManager:
    __base: |-
      if (!('getBattery' in navigator)) {
        return {result: false, message: 'navigator.getBattery() is not defined'};
      };
      var promise = navigator.getBattery();
      promise.then(function() {});
  BeforeInstallPromptEvent:
    __base: |-
      try {
        var instance = new BeforeInstallPromptEvent('');
      } catch(e) {
        if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
          return {result: false, message: 'Cannot create event'};
        }
        throw e;
      }
  BeforeUnloadEvent:
    __base: |-
      try {
        var instance = document.createEvent('BeforeUnloadEvent');
      } catch(e) {
        if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
          return {result: false, message: 'Cannot create event'};
        }
        throw e;
      }
  BiquadFilterNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createBiquadFilter' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createBiquadFilter is not defined'};
      }
      var instance = reusableInstances.audioContext.createBiquadFilter();
  Blob:
    __base: |-
      var instance;
      try {
        instance = new Blob();
      } catch(e) {
        instance = new BlobBuilder();
      }
  Bluetooth:
    __base: var instance = navigator.bluetooth;
  ByteLengthQueuingStrategy:
    __base: |-
      if (!('ByteLengthQueuingStrategy' in self)) {
        return {result: false, message: 'ByteLengthQueuingStrategy is not defined'};
      }
      var instance = new ByteLengthQueuingStrategy({ highWaterMark: 1 });
  CacheStorage:
    __base: |-
      if (!('caches' in self)) {
        return {result: false, message: 'caches is not defined'};
      };
      var instance = caches;
  CanvasCaptureMediaStreamTrack:
    __base: |-
      var canvas = document.createElement('canvas');
      if (!canvas) {
        return {result: false, message: 'Could not create canvas element'};
      };
      var stream = canvas.captureStream(60);
      var tracks = stream.getTracks();
      var instance = tracks[0];

      var nameResult = bcd.testObjectName(instance, 'CanvasCaptureMediaStreamTrack');
      if (!(nameResult.result)) {
        return nameResult
      }
  CanvasGradient:
    __base: |-
      <%api.CanvasRenderingContext2D:ctx%>
      var instance;
      if (ctx.createLinearGradient) {
        instance = ctx.createLinearGradient(0, 0, 1, 1);
      } else if (ctx.createRadialGradient) {
        instance = ctx.createRadialGradient(0, 0, 0, 1, 1, 1);
      } else {
        return {result: false, message: 'Could not create linear or radial gradient'};
      }
  CanvasPattern:
    __resources:
      - image-black
    __base: |-
      <%api.CanvasRenderingContext2D:ctx%>
      var instance = ctx.createPattern(document.getElementById('resource-image-black'), 'repeat');
    setTransform:
      __additional:
        dommatrix: |-
          <%api.DOMMatrix:matrix%>
          if (!(instance && instance.setTransform)) {
            return {result: false, message: 'instance.setTransform is not defined'};
          }
          try {
            instance.setTransform(matrix);
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
  CanvasRenderingContext2D:
    __resources:
      - image-black # Used in drawImage.ImageBitmap_source_image, XXX remove when imports include resources
    __base: |-
      if (!('document' in self)) {
        // XXX Implement worker tests for CanvasRenderingContext2D
        return {result: null, message: 'Testing CanvasRenderingContext2D in workers is not yet implemented'};
      }
      var canvas = document.createElement('canvas');
      if (!canvas) {
        return {result: false, message: 'Could not create canvas element'};
      };
      var instance = canvas.getContext('2d');
    clip:
      __additional:
        path_parameter: |-
          <%api.Path2D:path%>
          if (!(instance && instance.clip)) {
            return {result: false, message: 'instance.clip is not defined'};
          }
          try {
            instance.clip(path);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    drawFocusIfNeeded:
      __additional:
        path_parameter: |-
          <%api.Path2D:path%>
          <%api.HTMLElement:el%>
          if (!(instance && instance.drawFocusIfNeeded)) {
            return {result: false, message: 'instance.drawFocusIfNeeded is not defined'};
          }
          try {
            instance.drawFocusIfNeeded(path, el);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    drawImage:
      __additional:
        ImageBitmap_source_image: |-
          <%api.ImageBitmap:imgbmpPromise%>
          var promise = imgbmpPromise.then(function(imgbmp) {
            instance.drawImage(imgbmp, 0, 0);
            return true;
          }).catch(function(e) {
            if (e.name === 'TypeError') {
              // A TypeError is thrown for lack of support
              return {result: false, message: e.message};
            }
            throw e;
          });

          return promise;
        SVGImageElement_source_image: |-
          <%api.SVGImageElement:image%>
          try {
            instance.drawImage(image, 0, 0);
            return true;
          } catch (e) {
            if (e.name === 'TypeError') {
              // A TypeError is thrown for lack of support
              return {result: false, message: e.message};
            }
            throw e;
          }
    fill:
      __additional:
        path_parameter: |-
          <%api.Path2D:path%>
          try {
            instance.fill(path);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    isPointInPath:
      __additional:
        path_parameter: |-
          <%api.Path2D:path%>
          try {
            instance.isPointInPath(path, 0, 0);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    isPointInStroke:
      __additional:
        path_parameter: |-
          <%api.Path2D:path%>
          try {
            instance.isPointInStroke(path, 0, 0);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    setTransform:
      __additional:
        matrix_parameter: |-
          var matrix = new DOMMatrix([1, .2, .8, 1, 0, 0]);
          try {
            instance.setTransform(matrix);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    stroke:
      __additional:
        path_parameter: |-
          <%api.Path2D:path%>
          try {
            instance.stroke(path);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
  ChannelMergerNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createChannelMerger' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createChannelMerger is not defined'};
      }
      var instance = reusableInstances.audioContext.createChannelMerger();
  ChannelSplitterNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createChannelSplitter' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createChannelSplitter is not defined'};
      }
      var instance = reusableInstances.audioContext.createChannelSplitter();
  CharacterData:
    __base: <%api.Text:instance%>
  Client:
    __base: |-
      var promise = clients.matchAll({
        includeUncontrolled: true
      }).then((clientList) => {
        return clientList.length && clientList[0];
      });
  Clients:
    __base: var instance = clients;
    matchAll:
      __additional:
        options_includeUncontrolled_parameter: return bcd.testOptionParam(instance, 'matchAll', 'includeUncontrolled', true);
  Clipboard:
    __base: var instance = navigator.clipboard;
  CloseEvent:
    __base: |-
      var instance;
      try {
        instance = new CloseEvent('close');
      } catch(e) {
        try {
          instance = document.createEvent('CloseEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  CompositionEvent:
    __base: |-
      var instance;
      try {
        instance = new CompositionEvent('compositionstart');
      } catch(e) {
        try {
          instance = document.createEvent('CompositionEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  CompressionStream:
    __base: |-
      if (!('CompressionStream' in self)) {
        return {result: false, message: 'CompressionStream is not defined'};
      }
      var instance = new CompressionStream("gzip");
    CompressionStream:
      __additional:
        deflate: |-
          try {
            new CompressionStream("deflate");
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
        deflate-raw: |-
          try {
            new CompressionStream("deflate-raw");
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
        gzip: |-
          try {
            new CompressionStream("gzip");
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
  ConstantSourceNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createConstantSource' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createConstantSource is not defined'};
      }
      var instance = reusableInstances.audioContext.createConstantSource();
  ConvolverNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createConvolver' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createConvolver is not defined'};
      }
      var instance = reusableInstances.audioContext.createConvolver();
  CookieStore:
    __base: |-
      if (!('cookieStore' in self)) {
        return {result: false, message: 'cookieStore is not defined'};
      }
      var instance = cookieStore;
    __additional:
      delete.partitioned_option: "return bcd.testOptionParam(cookieStore, 'delete', 'partitioned', true, {'name': 'one'});"
      set.partitioned_option: |-
        bcd.addCleanup(function() {
          cookieStore.delete({'name': 'two', 'partitioned': true});  
        });
        return bcd.testOptionParam(cookieStore, 'set', 'partitioned', true, {'name': 'two', 'value': 'bar'});
      get.partitioned_return_property: |-
        bcd.addCleanup(function() {
          cookieStore.delete({'name': 'three', 'partitioned': true});  
        });
        return cookieStore.set({'name': 'three', 'value': 'bar', 'partitioned': true}).then(function() {
          return cookieStore.get('three');
        }).then(function(cookie) {
          return 'partitioned' in cookie;
        });
      getAll.partitioned_return_property: |-
        bcd.addCleanup(function() {
          cookieStore.delete({'name': 'four', 'partitioned': true});  
        });
        return cookieStore.set({'name': 'four', 'value': 'bar', 'partitioned': true}).then(function() {
          return cookieStore.getAll();
        }).then(function(cookies) {
          return 'partitioned' in cookies[0];
        });
  CountQueuingStrategy:
    __base: |-
      if (!('CountQueuingStrategy' in self)) {
        return {result: false, message: 'CountQueuingStrategy is not defined'};
      }
      var instance = new CountQueuingStrategy({ highWaterMark: 1 });
  createImageBitmap:
    __resources:
      - image-black
    __base: |-
      if (!('createImageBitmap' in self)) {
        return {result: false, message: 'createImageBitmap is not defined'};
      }
      function create(options) {
        return createImageBitmap(document.getElementById('resource-image-black'), options);
      }
    __test: return true;
    __additional:
      options_colorSpaceConversion_parameter: return bcd.testOptionParam(create, null, 'colorSpaceConversion', 'default');
      options_imageOrientation_parameter: return bcd.testOptionParam(create, null, 'imageOrientation', 'none');
      options_premultiplyAlpha_parameter: return bcd.testOptionParam(create, null, 'premultiplyAlpha', 'default');
      options_resizeHeight_parameter: return bcd.testOptionParam(create, null, 'resizeHeight', '100');
      options_resizeQuality_parameter: return bcd.testOptionParam(create, null, 'resizeQuality', 'high');
      options_resizeWidth_parameter: return bcd.testOptionParam(create, null, 'resizeWidth', '100');
      svgimageelement_as_source_image: |-
        <%api.SVGImageElement:svgimg%>
        try {
          createImageBitmap(svgimg);
          return true;
        } catch(e) {
          return {result: false, message: e.message};
        }
  CredentialsContainer:
    __resources:
      - cryptoKey
    __base: var instance = navigator.credentials;
    create:
      __additional:
        publicKey_option: return bcd.testOptionParam(instance, 'create', 'publicKey', reusableInstances.cryptoKey);
    get:
      __additional:
        identity_option: "return bcd.testOptionParam(instance, null, 'get', 'identity');"
        identity_option.context_option: |-
          function get(identity) {
            instance.get({identity: identity});
          }
          return bcd.testOptionParam(get, null, 'context', 'use');
        identity_option.loginHint: |-
          function get(provider) {
            instance.get({identity: {providers: [provider]}});
          }
          return bcd.testOptionParam(get, null, 'loginHint', 'foo', {configURL: '', clientId: ''});
        otp_option: "return bcd.testOptionParam(instance, 'get', 'otp', {transport: 'sms'});"
        publicKey_option: return bcd.testOptionParam(instance, 'get', 'publicKey', reusableInstances.cryptoKey);
  Crypto:
    __base: |-
      if (!('crypto' in self)) {
        return {result: false, message: 'crypto is not defined'};
      };
      var instance = crypto;
  CryptoKey:
    __resources:
      - cryptoKey
    __base: |-
      var promise = reusableInstances.cryptoKey;
  CSPViolationReportBody:
    __base: |-
      // Note: the Content-Security-Policy header is already configured on this website
      if (!('ReportingObserver' in self)) {
        return {result: false, message: 'ReportingObserver is not defined'};
      }

      // Create the observer
      var observer = new ReportingObserver(
        function(reports, observer) {
          var instance = reports.length && reports[0].body;
          callback(instance);
          el.remove();
          observer.disconnect();
        },
        {
          types: ["csp-violation"],
          buffered: true,
        }
      );

      // Start observing
      observer.observe();

      // Load some "script" from bad-domain.awful
      var el = document.createElement('script');
      el.src = "//bad-domain.awful/dummy-script.js";
      try {
        document.getElementById('resources').append(el);
      } catch(e) {
        // We expect a CSP error here
      }
    toJSON: |-
      function callback(instance) {
        try {
          success(!!instance && 'toJSON' in instance);
        } catch(e) {
          fail(e);
        }
      }
      return 'callback';
  CSSConditionRule:
    __resources:
      - createStyleSheet
    __base: |-
      <%api.CSSMediaRule:instance%>
      if (!('conditionText' in instance)) {
        return {result: false, message: 'CSSConditionRule instance must have "conditionText" property, which is missing from this instance'};
      }
  CSSCounterStyleRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@counter-style thumbs {system: cyclic; symbols: "üëç"; suffix: " ";}');
      var instance = stylesheet.cssRules.item(0);
  CSSFontFaceRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@font-face {font-family: somefont; src: url(somefont.ttf);}');
      var instance = stylesheet.cssRules.item(0);
  CSSFontFeatureValuesRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@font-feature-values Font {@styleset {nice-style: 12;}}');
      var instance = stylesheet.cssRules.item(0);
  CSSGroupingRule:
    __resources:
      - createStyleSheet
    __base: |-
      <%api.CSSMediaRule:instance%>
      if (!('cssRules' in instance)) {
        return {result: false, message: 'CSSGroupingRule instance must have "cssRules" property, which is missing from this instance'};
      }
  CSSImportRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@import url(/resources/style.css);');
      var instance = stylesheet.cssRules.item(0);
  CSSKeyframeRule:
    __resources:
      - createStyleSheet
    __base: |-
      <%api.CSSKeyframesRule:keyframes%>
      var instance = keyframes.cssRules.item(0);
  CSSKeyframesRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@keyframes test {0% {top: 0 } 100% { top: 100px; }} @-webkit-keyframes test {0% { top: 0 } 100% { top: 100px; }} @-moz-keyframes test {0% { top: 0 } 100% { top: 100px; }} @-o-keyframes test {0% { top: 0 } 100% { top: 100px; }}');
      var instance = stylesheet.cssRules.item(0);
  CSSMediaRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@media (max-width: 600px) {body {background-color: #111;color: white;}}');
      var instance = stylesheet.cssRules.item(0);
  CSSNamespaceRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@namespace svg url(http://www.w3.org/2000/svg);');
      var instance = stylesheet.cssRules.item(0);
  CSSPageRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@page {margin: 1cm;}');
      var instance = stylesheet.cssRules.item(0);
  CSSRule:
    __resources:
      - createStyleSheet
    __base: |-
      <%api.CSSRuleList:cssRules%>
      var instance = cssRules.item(0);
  CSSRuleList:
    __resources:
      - createStyleSheet
    __base: |-
      <%api.CSSStyleSheet:stylesheet%>
      var instance = stylesheet.cssRules;
  CSSStyleDeclaration:
    __base: |-
      var el = document.createElement('b');
      var instance = el.style;
  CSSStyleRule:
    __resources:
      - createStyleSheet
    __base: <%api.CSSRule:instance%>
  CSSStyleSheet:
    __resources:
      - createStyleSheet
    __base: "var instance = reusableInstances.createStyleSheet('p {color: red;}');"
    insertRule:
      __additional:
        index_parameter_optional: |-
          if (!(instance && instance.insertRule)) {
            return {result: false, message: 'instance.insertRule is not defined'};
          }
          try {
            instance.insertRule('a {color: blue;}');
            return true;
          } catch(e) {
            if (e instanceof TypeError || stringIncludes(e.message, ['WRONG_ARGUMENTS_ERR', 'Not enough arguments'])) {
              return {result: false, message: e.message};
            }
            return e;
          }
  CSSSupportsRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@supports (display: grid) {div {display: grid;}}');
      var instance = stylesheet.cssRules.item(0);
  CSSViewportRule:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@viewport {width: 100vw;}');
      var instance = stylesheet.cssRules.item(0);
  CustomElementRegistry:
    __base: var instance = window.customElements;
    __additional:
      builtin_element_support: |-
        // Create a class for the element
        class MyCustomElement extends HTMLParagraphElement {
          constructor() {
            // Always call super first in constructor
            super();
          }
        }

        function define(options) {
          customElements.define("my-custom-element", MyCustomElement, options);
        }
        return bcd.testOptionParam(define, null, "extends", "p");
  CustomEvent:
    __base: |-
      var instance;
      try {
        instance = new CustomEvent('custom');
      } catch(e) {
        try {
          instance = document.createEvent('CustomEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  DecompressionStream:
    __base: |-
      if (!('DecompressionStream' in self)) {
        return {result: false, message: 'DecompressionStream is not defined'};
      }
      var instance = new DecompressionStream("gzip");
    DecompressionStream:
      __additional:
        deflate: |-
          try {
            new DecompressionStream("deflate");
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
        deflate-raw: |-
          try {
            new DecompressionStream("deflate-raw");
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
        gzip: |-
          try {
            new DecompressionStream("gzip");
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
  DelayNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createDelay' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createDelay is not defined'};
      }
      var instance = reusableInstances.audioContext.createDelay();
  DeprecationReportBody:
    __base: |-
      // XXX Obtaining an instance of this interface is much like triggering an event.
      // See http://developer.mozilla.org/docs/Web/API/DeprecationReportBody#examples
      return {result: null, message: 'Testing DeprecationReportBody is not yet implemented'};
    toJSON: return null;
  DeviceMotionEvent:
    __base: |-
      var instance;
      try {
        instance = new DeviceMotionEvent('devicemotion', {acceleration: {x: 1, y: 1, z: 1}, rotationRate: {alpha: 1, beta: 1, gamma: 1}});
      } catch(e) {
        try {
          instance = document.createEvent('DeviceMotionEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  DeviceMotionEventAcceleration:
    __base: |-
      <%api.DeviceMotionEvent:event%>
      var instance = event.acceleration;
  DeviceMotionEventRotationRate:
    __base: |-
      <%api.DeviceMotionEvent:event%>
      var instance = event.rotationRate;
  DeviceOrientationEvent:
    __base: |-
      var instance;
      try {
        instance = new DeviceOrientationEvent('deviceorientation');
      } catch(e) {
        try {
          instance = document.createEvent('DeviceOrientationEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  Document:
    __base: var instance = document;
    createElement:
      __additional:
        options_parameter: |-
          function doTest(options) {
            instance.createElement('p', options);
          }
          return bcd.testOptionParam(doTest, null, 'is', '');
    createElementNS:
      __additional:
        options_parameter: |-
          function doTest(options) {
            instance.createElementNS('http://www.w3.org/1999/xhtml', 'p', options);
          }
          return bcd.testOptionParam(doTest, null, 'is', '');
    createTreeWalker:
      __additional:
        whatToShow_filter_parameters_optional: |-
          try {
            instance.createTreeWalker(document.body);
            return true;
          } catch(e) {
            if (stringIncludes(e.message, ['WRONG_ARGUMENTS_ERR', 'Not enough arguments'])) {
              return {result: false, message: e.message};
            }
            return e;
          }
    exitFullscreen:
      __additional:
        returns_promise: |-
          if (!('Promise' in self)) {
            return {result: false, message: 'Promises are not supported'};
          }
          var value = document.exitFullscreen();
          return 'then' in value;
  DocumentFragment:
    __base: |-
      if (!('createDocumentFragment' in document)) {
        return {result: false, message: 'document.createDocumentFragment is not defined'};
      }
      var instance = document.createDocumentFragment();
  DocumentType:
    __base: |-
      if (!('doctype' in document)) {
        return {result: false, message: 'document.doctype is not defined'};
      }
      var instance = document.doctype;
  DOMError:
    __base: |-
      if (!('DOMError' in self)) {
        return {result: false, message: 'DOMError is not defined'};
      }
      var instance = new DOMError('name');
  DOMException:
    __base: |-
      var instance;
      try {
        document.createElement('1');
      } catch (e) {
        instance = e;
      }
  DOMImplementation:
    __base: var instance = document.implementation;
  DOMMatrix:
    __base: |-
      var instance;
      if ('DOMMatrix' in self) {
        instance = new DOMMatrix();
      } else if ('WebKitCSSMatrix' in self) {
        instance = new WebKitCSSMatrix();
      } else if ('SVGMatrix' in self) {
        instance = new SVGMatrix();
      } else {
        return {result: false, message: 'DOMMatrix, WebKitCSSMatrix and SVGMatrix are not defined.'}
      }
  DOMParser:
    __base: |-
      if (!('DOMParser' in self)) {
        return {result: false, message: 'DOMParser is not defined'}
      }
      var instance = new DOMParser();
    parseFromString:
      __additional:
        html: |-
          if (!(instance && instance.parseFromString)) {
            return {result: false, message: 'instance.parseFromString is not defined'};
          }
          try {
            instance.parseFromString('<html></html>', 'text/html');
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
        svg: |-
          if (!(instance && instance.parseFromString)) {
            return {result: false, message: 'instance.parseFromString is not defined'};
          }
          try {
            instance.parseFromString('<circle />', 'image/svg+xml');
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
        xml: |-
          if (!(instance && instance.parseFromString)) {
            return {result: false, message: 'instance.parseFromString is not defined'};
          }
          try {
            instance.parseFromString('<foo />', 'text/xml');
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
  DOMRectList:
    __base: |-
      <%api.Element:el%>
      if (!('getClientRects' in el)) {
        return {result: false, message: 'el.getClientRects is not defined'};
      }
      var instance = el.getClientRects();
  DOMTokenList:
    __base: |-
      var el = document.createElement('b');
      var instance = el.classList;
    __additional:
      trim_whitespace: |-
        if (!instance) {
          return {result: false, message: 'Element.classList is not defined'};
        }
        el.className = ' foo bar foo ';
        instance.remove('bar');
        return el.className === 'foo foo' || el.className === 'foo';
      remove_duplicates: |-
        if (!instance) {
          return {result: false, message: 'Element.classList is not defined'};
        }
        el.className = ' foo bar foo ';
        instance.remove('bar');
        return el.className === 'foo';
    add:
      __additional:
        multiple_parameters: |-
          instance.add("foo", "bar", "baz");
          return el.className === "foo bar baz";
    remove:
      __additional:
        multiple_parameters: |-
          instance.add("foo", "bar", "baz");
          instance.remove("bar", "baz");
          return el.className === "foo";
    replace:
      __additional:
        boolean_value: |-
          instance.add("foo");
          var value = instance.replace("foo", "bar");
          return value === true;
    toggle:
      __additional:
        force_parameter: |-
          if (!instance) {
            return {result: false, message: 'Element.classList is not defined'};
          }
          if (!('toggle' in instance)) {
            return {result: false, message: 'Element.classList.toggle is not defined'};
          }
          el.className = 'foo bar';

          instance.toggle('foo', true);
          return el.className === 'foo bar';
  DragEvent:
    __base: |-
      var instance;
      try {
        instance = new DragEvent('drag');
      } catch(e) {
        try {
          instance = document.createEvent('DragEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  DynamicsCompressorNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createDynamicsCompressor' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createDynamicsCompressor is not defined'};
      }
      var instance = reusableInstances.audioContext.createDynamicsCompressor();
  Element:
    __base: |-
      var instance;
      try {
        instance = document.createElementNS('', 'el');
      } catch(e) {
        instance = document.createElement('b');
      }
    animate:
      __base: |-
        if (!(instance && instance.animate)) {
          return {result: false, message: 'instance.animate is not defined'};
        }
        function animate(options) {
          instance.animate(
            [
              { transform: 'rotate(0) scale(1)' },
              { transform: 'rotate(360deg) scale(0)' }
            ],
            options
          )
        }
      __additional:
        options_composite_parameter: return bcd.testOptionParam(animate, null, 'composite', 'replace');
        options_id_parameter: return bcd.testOptionParam(animate, null, 'id', '');
        options_iterationComposite_parameter: return bcd.testOptionParam(animate, null, 'iterationComposite', '');
        options_pseudoElement_parameter: return bcd.testOptionParam(animate, null, 'pseudoElement', '');
        options_rangeEnd_parameter: return bcd.testOptionParam(animate, null, 'rangeEnd', 'normal');
        options_rangeStart_parameter: return bcd.testOptionParam(animate, null, 'rangeStart', 'normal');
        options_timeline_parameter: return bcd.testOptionParam(animate, null, 'timeline', document.timeline);
    attachShadow:
      __additional:
        init_clonable_parameter: |-
          // Only specific elements may have shadows attached -- see
          // https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow#elements_you_can_attach_a_shadow_to
          var el = document.createElement('main');
          return bcd.testOptionParam(el, 'attachShadow', 'clonable', true, {mode: 'open'});
        init_delegatesFocus_parameter: |-
          // Only specific elements may have shadows attached -- see
          // https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow#elements_you_can_attach_a_shadow_to
          var el = document.createElement('main');
          return bcd.testOptionParam(el, 'attachShadow', 'delegatesFocus', true, {mode: 'open'});
    checkVisibility:
      __additional:
        options_checkOpacity_parameter: "return bcd.testOptionParam(interface, 'checkVisibility', 'checkOpacity', true);"
        options_checkVisibilityCSS_parameter: "return bcd.testOptionParam(interface, 'checkVisibility', 'checkVisibilityCSS', true);"
        options_contentVisibilityAuto_parameter: "return bcd.testOptionParam(interface, 'checkVisibility', 'contentVisibilityAuto', true);"
        options_visibilityProperty_parameter: "return bcd.testOptionParam(interface, 'checkVisibility', 'visibilityProperty', true);"
    getElementsByTagName:
      __additional:
        all_elements_selector: |-
          if (!(instance && instance.getElementsByTagName)) {
            return {result: false, message: 'instance.getElementsByTagName is not defined'};
          }
          instance.append(document.createElement('p'));
          return instance.getElementsByTagName("*").length > 0;
    getElementsByTagNameNS:
      __additional:
        all_elements_selector: |-
          if (!(instance && instance.getElementsByTagNameNS)) {
            return {result: false, message: 'instance.getElementsByTagNameNS is not defined'};
          }
          instance.append(document.createElement('p'));
          return instance.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", "*").length > 0;
    requestFullscreen:
      __additional:
        options_navigationUI_parameter: return bcd.testOptionParam(instance, 'requestFullscreen', 'navigationUI', false);
        returns_promise: |-
          if (!(instance && instance.requestFullscreen)) {
            return {result: false, message: 'instance.requestFullscreen is not defined'};
          }
          var value = instance.requestFullscreen();
          return 'then' in value;
    requestPointerLock:
      __additional:
        options_unadjustedMovement_parameter: return bcd.testOptionParam(instance, 'requestFullscreen', 'unadjustedMovement', false);
    scroll:
      __additional:
        options_behavior_parameter: return bcd.testOptionParam(instance, 'scroll', 'behavior', 'auto');
        options_left_parameter: return bcd.testOptionParam(instance, 'scroll', 'left', '0');
        options_top_parameter: return bcd.testOptionParam(instance, 'scroll', 'top', '0');
    scrollBy:
      __additional:
        options_behavior_parameter: return bcd.testOptionParam(instance, 'scrollBy', 'behavior', 'auto');
        options_left_parameter: return bcd.testOptionParam(instance, 'scrollBy', 'left', '0');
        options_top_parameter: return bcd.testOptionParam(instance, 'scrollBy', 'top', '0');
    scrollIntoView:
      __additional:
        options_parameter: return bcd.testOptionParam(instance, 'scrollIntoView', 'behavior', 'auto');
    scrollTo:
      __additional:
        options_behavior_parameter: return bcd.testOptionParam(instance, 'scrollTo', 'behavior', 'auto');
        options_left_parameter: return bcd.testOptionParam(instance, 'scrollTo', 'left', '0');
        options_top_parameter: return bcd.testOptionParam(instance, 'scrollTo', 'top', '0');
  EntrySync:
    __base: |-
      // XXX Need to find a "safe" file path that can be used
      var instance = self.webkitResolveLocalFileSystemSyncURL('');
  ErrorEvent:
    __base: |-
      var instance;
      try {
        instance = new ErrorEvent('error');
      } catch(e) {
        try {
          instance = document.createEvent('ErrorEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  Event:
    __base: |-
      var instance;
      try {
        instance = new Event('type');
      } catch(e) {
        try {
          instance = document.createEvent('Event');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  EventSource:
    __base: |-
      if (!('EventSource' in self)) {
        return {result: false, message: 'EventSource is not defined'};
      }
      var instance = new EventSource('/eventstream');
      bcd.addCleanup(function() {
        instance.close();
      });
    EventSource:
      __test: return !!instance;
      __additional:
        options_withCredentials_parameter: |-
          function construct(options) {
            new EventSource('https://mdn-bcd-collector.gooborg.com', options);
          }
          return bcd.testOptionParam(construct, null, 'withCredentials', true);
  EventTarget:
    __base: |-
      var instance;
      try {
        instance = new EventTarget();
      } catch(e) {
        // XXX Determine a way to get an event target in worker contexts if EventTarget() isn't a constructor
        <%api.Element:el%>
        instance = el;
      }
    addEventListener:
      __base: |-
        function addEventListener(options) {
          instance.addEventListener('click', function() {}, options);
        }
      __additional:
        options_parameter: return bcd.testOptionParam(addEventListener, null, 'capture', true);
        options_parameter.options_capture_parameter: return bcd.testOptionParam(addEventListener, null, 'capture', true);
        options_parameter.options_once_parameter: return bcd.testOptionParam(addEventListener, null, 'once', true);
        options_parameter.options_passive_parameter: return bcd.testOptionParam(addEventListener, null, 'passive', true);
        options_parameter.options_signal_parameter: |-
          if (!('AbortController' in self)) {
            return {result: false, message: 'AbortController is not defined'};
          }
          var controller = new AbortController();
          var signal = controller.signal;
          return bcd.testOptionParam(addEventListener, null, 'signal', signal);
        useCapture_parameter_optional: |-
          try {
            instance.addEventListener('click', function() {});
            return true;
          } catch(e) {
            if (e.name === 'TypeError') {
              return {result: false, message: 'useCapture parameter is required'};
            }
            throw e;
          }
    removeEventListener:
      __base: |-
        function removeEventListener(options) {
          function eventListener() {}
          instance.addEventListener('click', eventListener, options);
          instance.removeEventListener('click', eventListener, options);
        }
      __additional:
        options_parameter: return bcd.testOptionParam(removeEventListener, null, 'capture', true);
        useCapture_parameter_optional: |-
          try {
            function eventListener() {}
            instance.addEventListener('click', eventListener);
            instance.removeEventListener('click', eventListener);
            return true;
          } catch(e) {
            if (e.name === 'TypeError') {
              return {result: false, message: 'useCapture parameter is required'};
            }
            throw e;
          }
  EXT_blend_minmax:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_blend_minmax');
  EXT_clip_cull_distance:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('EXT_clip_cull_distance');
  EXT_color_buffer_float:
    __resources:
      - webGL2
    __base: |-
      if (!reusableInstances.webGL2) {
        return {result: false, message: 'WebGL 2 is not available'};
      };
      var instance = reusableInstances.webGL2.getExtension('EXT_color_buffer_float');
  EXT_color_buffer_half_float:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_color_buffer_half_float');
  EXT_disjoint_timer_query:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_disjoint_timer_query');
  EXT_disjoint_timer_query_webgl2:
    __resources:
      - webGL2
    __base: |-
      if (!reusableInstances.webGL2) {
        return {result: false, message: 'WebGL 2 is not available'};
      };
      var instance = reusableInstances.webGL2.getExtension('EXT_disjoint_timer_query_webgl2');
  EXT_float_blend:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('EXT_float_blend');
  EXT_frag_depth:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_frag_depth');
  EXT_shader_texture_lod:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_shader_texture_lod');
  EXT_sRGB:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('EXT_sRGB');
  EXT_texture_compression_bptc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('EXT_texture_compression_bptc');
  EXT_texture_compression_rgtc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('EXT_texture_compression_rgtc');
  EXT_texture_filter_anisotropic:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('EXT_texture_filter_anisotropic');
  EXT_texture_norm16:
    __resources:
      - webGL2
    __base: |-
      if (!reusableInstances.webGL2) {
        return {result: false, message: 'WebGL 2 is not available'};
      };
      var instance = reusableInstances.webGL2.getExtension('EXT_texture_norm16');
  ExtendableEvent:
    __base: |-
      if (!('ExtendableEvent' in self)) {
        return {result: false, message: 'ExtendableEvent is not defined'};
      }
      var instance = new ExtendableEvent('extendable');
  External:
    __base: var instance = window.external;
  FeaturePolicy:
    __base: var instance = document.featurePolicy;
  FetchEvent:
    __base: |-
      <%api.Request:req%>
      if (!('FetchEvent' in self)) {
        return {result: false, message: 'FetchEvent is not defined'};
      }
      var instance = new FetchEvent('fetch', { request: req });
  FileReader:
    __base: var instance = new FileReader();
  FileSystem:
    __base: |-
      if (!('webkitRequestFileSystem') in self) {
        return {result: false, message: 'webkitRequestFileSystem is not defined'};
      }
      self.webkitRequestFileSystem(TEMPORARY, 8*1024 /* 8KB */, function(fs) {
        callback(fs);
      }, function(error) {
        fail(error.message);
      });
  FileSystemEntry:
    __base: <%api.FileSystemDirectoryEntry:callback%>
  FileSystemDirectoryEntry:
    __base: |-
      <%api.FileSystem:fsCallback%>
      function fsCallback(fs) {
        callback(fs.root);
      }
  FileSystemDirectoryReader:
    __base: |-
      <%api.FileSystemDirectoryEntry:dirCallback%>
      function dirCallback(dir) {
        callback(dir.createReader());
      }
  FileSystemFileEntry:
    __base: |-
      <%api.FileSystem:fsCallback%>
      function fsCallback(fs) {
        fs.root.getFile('foo.txt', { create: true }, function(file) {
          callback(file);
        }, function(event) {
          fail(event.message);
        });
      }
  FileSystemSync:
    __base: |-
      if (!('webkitRequestFileSystemSync') in self) {
        return {result: false, message: 'webkitRequestFileSystemSync is not defined'};
      }
      var instance = self.webkitRequestFileSystemSync(TEMPORARY, 8*1024 /* 8KB */);
  FocusEvent:
    __base: |-
      var instance;
      try {
        instance = new FocusEvent('focus');
      } catch(e) {
        try {
          instance = document.createEvent('FocusEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  FontFace:
    __base: |-
      if (!('FontFace' in self)) {
        return {result: false, message: 'FontFace is not defined'};
      }
      var instance = new FontFace('Material Design Icons', 'url(/fonts/materialdesignicons-webfont.woff)', {});
  FontFaceSet:
    __base: |-
      var instance;
      if ('document' in self) {
        instance = document.fonts;
      } else {
        instance = self.fonts;
      }
  FontFaceSetLoadEvent:
    __base: |-
      if (!('FontFaceSetLoadEvent' in self)) {
        return {result: false, message: 'FontFaceSetLoadEvent is not defined'};
      }
      var instance = new FontFaceSetLoadEvent('loading');
  FormData:
    __base: |-
      if (!('FormData' in self)) {
        return {result: false, message: 'FormData is not defined'};
      }
      var instance = new FormData();
    __additional:
      append.filename_parameter: |-
        <%api.Blob:blob%>
        function append(filename) {
          instance.append('foo', blob, filename);
        }
        return bcd.testOptionParam(append, null, null, 'foo.txt');
      FormData.submitter: |-
        if (!('document' in self)) {
          return {result: null, message: "Testing in workers is not yet implemented"};
        }
        var form = document.createElement('form');
        var btn = document.createElement('button');
        form.appendChild(btn);

        function create(submitter) {
          new FormData(form, submitter);
        }

        return bcd.testOptionParam(create, null, null, btn);
  GainNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createGain' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createGain is not defined'};
      }
      var instance = reusableInstances.audioContext.createGain();
  GamepadEvent:
    __base: |-
      if (!('GamepadEvent' in self)) {
        return {result: false, message: 'GamepadEvent is not defined'};
      }
      var instance = new GamepadEvent('gamepadconnected');
  Geolocation:
    __base: var instance = navigator.geolocation;
  GeolocationCoordinates:
    __base: |-
      <%api.GeolocationPosition:posCallback%>
      function posCallback(pos) {
        callback(pos.coords);
      }
  GeolocationPosition:
    __base: |-
      <%api.Geolocation:geo%>
      geo.getCurrentPosition(function(pos) {
        callback(pos);
      }, function(err) {
        fail(err.message);
      }, {
        timeout: 5000
      });
  GPU:
    __base: var instance = navigator.gpu;
  GPUAdapter:
    __base: |-
      <%api.GPU:gpu%>
      var promise = gpu.requestAdapter();
    __additional:
      requestDevice.lost_device_on_duplicate: |-
        return promise.then(function(adapter) {
          return adapter.requestDevice().then(function(device1) {
            bcd.addCleanup(function() {
              device1.destroy();
            });

            return adapter.requestDevice().then(function(device2) {
              bcd.addCleanup(function() {
                device2.destroy();
              });

              return new Promise(function(resolve) {
                var resolved = false;

                // The GPUDevice.lost promise will only resolve when the device is lost
                setTimeout(function() {
                  if (!resolved) {
                    resolve({result: false, message: 'GPUDevice.lost did not immediately resolve'});
                  }
                  resolved = true;
                }, 1000);

                device2.lost.then(function(info) {
                  if (!resolved) {
                    resolve({result: true, message: info.message});
                  }
                  resolved = true;
                });
              });
            });
          });
        });
  GPUBuffer:
    __base: |-
      <%api.GPUDevice:device%>
      if (!('GPUBufferUsage' in self)) {
        return {result: false, message: 'GPUBufferUsage is not defined'};
      }
      var promise = device.then(function(d) {
        return d.createBuffer({
          size: 1000,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
        });
      });
  GPUCommandEncoder:
    __base: |-
      <%api.GPUDevice:devicePromise%>
      var device;
      var promise = devicePromise.then(function(d) {
        device = d;
        return d.createCommandEncoder();
      });
  GPUComputePassEncoder:
    __base: |-
      <%api.GPUCommandEncoder:commandEncoder%>
      var promise = commandEncoder.then(function(ce) {
        var computePass = ce.beginComputePass();
        bcd.addCleanup(function() {
          computePass.end();
        });
        return computePass;
      });
  GPUDevice:
    __base: |-
      <%api.GPUAdapter:adapter%>
      var promise = adapter.then(function(a) {
        var device = a.requestDevice();
        bcd.addCleanup(function() {
          device.destroy();
        });
        return device;
      });
    importExternalTexture:
      __resources:
        - image-black
      __additional:
        videoframe_source: |-
          if (!('document' in self)) {
            // XXX Implement worker test
            return {result: null, message: 'Testing in workers is not yet implemented'};
          }

          return promise.then(function(instance) {
            if (!('importExternalTexture' in instance)) {
              return {result: false, message: 'GPUDevice.importExternalTexture is not defined'}
            }

            if (!('VideoFrame' in self)) {
              return {result: false, message: 'VideoFrame is not defined'}
            }

            var img = document.getElementById('resource-image-black');
            var videoFrame = new VideoFrame(img, {timestamp: 0});
            bcd.addCleanup(function() {
              videoFrame.close();
            });

            try {
              instance.importExternalTexture({source: videoFrame});
              return true;
            } catch(e) {
              return {result: false, message: e.message};
            }
          });
  GPUPipelineError:
    GPUPipelineError:
      __additional:
        message_optional: |-
          try {
            new GPUPipelineError(undefined, {reason: "internal"});
            return {result: true, message: 'Constructor passed with no errors'};
          } catch(e) {
            return {result: false, message: e.message};
          }
  GPUQueue:
    __base: |-
      <%api.GPUDevice:devicePromise%>
      var device;
      var promise = devicePromise.then(function(d) {
        device = d;
        return d.queue;
      });
    copyExternalImageToTexture:
      __resources:
        - image-black
      __additional:
        videoframe_source: |-
          if (!('document' in self)) {
            // XXX Implement worker test
            return {result: null, message: 'Testing in workers is not yet implemented'};
          }

          return promise.then(function(instance) {
            if (!('copyExternalImageToTexture' in instance)) {
              return {result: false, message: 'GPUQueue.copyExternalImageToTexture is not defined'}
            }

            // Create video frame
            if (!('VideoFrame' in self)) {
              return {result: false, message: 'VideoFrame is not defined'}
            }
            var img = document.getElementById('resource-image-black');
            var videoFrame = new VideoFrame(img, {timestamp: 0});
            bcd.addCleanup(function() {
              videoFrame.close();
            });

            // Create destination texture
            var cubeTexture = device.createTexture({
              size: [videoFrame.displayWidth, videoFrame.displayHeight, 1],
              format: "rgba8unorm",
              usage:
                GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_DST |
                GPUTextureUsage.RENDER_ATTACHMENT,
            });

            try {
              instance.copyExternalImageToTexture(
                { source: videoFrame },
                { texture: cubeTexture },
                [videoFrame.displayWidth, videoFrame.displayHeight]
              );
              return true;
            } catch(e) {
              return {result: false, message: e.message};
            }
          });
  GPURenderBundleEncoder:
    __base: |-
      <%api.GPUDevice:devicePromise%>
      var device;
      var promise = devicePromise.then(function(d) {
        device = d;
        return d.createRenderBundleEncoder({
          colorFormats: ['depth16unorm']
        });
      });
    setVertexBuffer:
      __additional:
        unset_vertex_buffer: |-
          return promise.then(function(passEncoder) {
            var vec4Size = 4 * Float32Array.BYTES_PER_ELEMENT;
            var vertexBuffer = device.createBuffer({
              size: 2 * 3 * vec4Size,
              usage: GPUBufferUsage.VERTEX,
              mappedAtCreation: true,
            });

            passEncoder.setVertexBuffer(0, vertexBuffer);

            try {
              passEncoder.setVertexBuffer(0, null);
              return true;
            } catch (e) {
              return {result: false, message: e.message}
            }
          });
  GPURenderPassEncoder:
    __base: |-
      <%api.GPUCommandEncoder:commandEncoder%>
      <%api.GPUTexture:texture%>
      var promise = commandEncoder.then(function(ce) {
        return texture.then(function(txtr) {
          var renderPassDescriptor = {
            colorAttachments: [
              {
                clearValue: [0.0, 0.5, 1.0, 1.0],
                loadOp: "clear",
                storeOp: "store",
                view: txtr.createView()
              },
            ],
          };
          var renderPass = ce.beginRenderPass(renderPassDescriptor);
          bcd.addCleanup(function() {
            renderPass.end();
          });
          return renderPass;
        });
      });
    setVertexBuffer:
      __additional:
        unset_vertex_buffer: |-
          return promise.then(function(passEncoder) {
            var vec4Size = 4 * Float32Array.BYTES_PER_ELEMENT;
            var vertexBuffer = device.createBuffer({
              size: 2 * 3 * vec4Size,
              usage: GPUBufferUsage.VERTEX,
              mappedAtCreation: true,
            });

            passEncoder.setVertexBuffer(0, vertexBuffer);

            try {
              passEncoder.setVertexBuffer(0, null);
              return true;
            } catch (e) {
              return {result: false, message: e.message}
            }
          });
  GPUTexture:
    __base: |-
      <%api.GPUDevice:device%>
      if (!('GPUTextureUsage' in self)) {
        return {result: false, message: 'GPUTextureUsage is not defined'};
      }
      var promise = device.then(function(d) {
        return d.createTexture({
          size: [512, 512, 1],
          format: "rgba8unorm",
          usage:
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.COPY_DST |
            GPUTextureUsage.RENDER_ATTACHMENT,
        });
      });
  HashChangeEvent:
    __base: |-
      var instance;
      try {
        instance = new HashChangeEvent('hashchange');
      } catch(e) {
        try {
          instance = document.createEvent('HashChangeEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  History:
    __base: var instance = history;
  HTMLAllCollection:
    __base: |-
      var instance = document.all;
      // Note: in most browsers, "document.all" is falsy, so "!!instance" will return "false"
      if (instance === undefined) {
        return {result: false, message: 'document.all is undefined'};
      }
    __test: return bcd.testObjectName(instance, 'HTMLAllCollection');
    item: return 'item' in instance;
    length: return 'length' in instance;
    namedItem: return 'namedItem' in instance;
  HTMLAnchorElement:
    __base: var instance = document.createElement('a');
    __test: return bcd.testObjectName(instance, 'HTMLAnchorElement');
    toString: |-
      instance.href = 'https://mdn-bcd-collector.gooborg.com/';
      return instance.toString() == instance.href;
    __additional:
      referrerPolicy.no-referrer-when-downgrade: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "no-referrer-when-downgrade";
        return instance.referrerPolicy == "no-referrer-when-downgrade";
      referrerPolicy.origin-when-cross-origin: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "origin-when-cross-origin";
        return instance.referrerPolicy == "origin-when-cross-origin";
      referrerPolicy.unsafe-url: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "unsafe-url";
        return instance.referrerPolicy == "unsafe-url";
  HTMLAreaElement:
    __base: var instance = document.createElement('area');
    __test: return bcd.testObjectName(instance, 'HTMLAreaElement');
    toString: |-
      instance.href = 'https://mdn-bcd-collector.gooborg.com/';
      return instance.toString() == instance.href;
    __additional:
      referrerPolicy.no-referrer-when-downgrade: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "no-referrer-when-downgrade";
        return instance.referrerPolicy == "no-referrer-when-downgrade";
      referrerPolicy.origin-when-cross-origin: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "origin-when-cross-origin";
        return instance.referrerPolicy == "origin-when-cross-origin";
      referrerPolicy.unsafe-url: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "unsafe-url";
        return instance.referrerPolicy == "unsafe-url";
  HTMLAudioElement:
    __base: var instance = document.createElement('audio');
    __test: return bcd.testObjectName(instance, 'HTMLAudioElement');
    Audio: return bcd.testConstructor('Audio');
  HTMLBaseElement:
    __base: var instance = document.createElement('base');
    __test: return bcd.testObjectName(instance, 'HTMLBaseElement');
  HTMLBaseFontElement:
    __base: var instance = document.createElement('basefont');
    __test: return bcd.testObjectName(instance, 'HTMLBaseFontElement');
  HTMLBodyElement:
    __base: var instance = document.createElement('body');
    __test: return bcd.testObjectName(instance, 'HTMLBodyElement');
  HTMLBRElement:
    __base: var instance = document.createElement('br');
    __test: return bcd.testObjectName(instance, 'HTMLBRElement');
  HTMLButtonElement:
    __base: var instance = document.createElement('button');
    __test: return bcd.testObjectName(instance, 'HTMLButtonElement');
  HTMLCanvasElement:
    __resources:
      - webGL1
      - webGL2
    __base: var instance = document.createElement('canvas');
    __test: return bcd.testObjectName(instance, 'HTMLCanvasElement');
    toBlob:
      __additional:
        quality_parameter: |-
          if (!('toBlob' in instance)) {
            return {result: false, message: "instance.toBlob is not defined"}
          }

          // Set the size
          instance.width = '300';
          instance.height = '300';

          // Now we need to draw something
          var ctx = instance.getContext('2d');
          ctx.lineWidth = 10;
          ctx.strokeStyle = "rgb(230, 20, 20)";
          ctx.fillStyle = "rgb(20, 20, 230)";
          ctx.strokeRect(75, 140, 150, 110);
          ctx.fillRect(130, 190, 40, 60);
          ctx.beginPath();
          ctx.moveTo(50, 140);
          ctx.lineTo(150, 60);
          ctx.lineTo(250, 140);
          ctx.closePath();
          ctx.stroke();

          // Get two blobs with different quality and compare them
          instance.toBlob(function(blob1) {
            blob1.arrayBuffer().then(function(blob1data) {
              instance.toBlob(function(blob2) {
                blob2.arrayBuffer().then(function(blob2data) {
                  if (blob1.size != blob2.size) {
                    success({result: true, message: 'Blobs are not identical'});
                    return;
                  }

                  for (var i = 0; i < blob1.size; i++) {
                    if (blob1data[i] != blob2data[i]) {
                      success({result: true, message: 'Blobs are not identical'});
                      return;
                    }
                  }

                  success({result: false, message: 'Blobs are identical'});
                });
              }, 'image/jpeg', 0.9);
            });
          }, 'image/jpeg', 0.5);

          return 'callback';
        type_parameter_webp: |-
          if (!('toBlob' in instance)) {
            return {result: false, message: "instance.toBlob is not defined"}
          }
          function callback(blob) {
            success(blob.type === 'image/webp');
          }
          instance.toBlob(callback, 'image/webp');
          return 'callback';
    toDataURL:
      __additional:
        type_parameter_webp: |-
          if (!('toDataURL' in instance)) {
            return {result: false, message: "instance.toDataURL is not defined"}
          }
          var blob = instance.toDataURL('image/webp');
          return blob.type === 'image/webp';
    getContext:
      __additional:
        bitmaprenderer_context: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          var ctx = instance.getContext('bitmaprenderer');
          return !!ctx;
        bitmaprenderer_context.options_alpha_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('bitmaprenderer', options);
          }
          return bcd.testOptionParam(createContext, null, 'alpha', true);
        webgl_context: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          var ctx = instance.getContext('webgl');
          return !!ctx;
        webgl_context.options_alpha_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('webgl', options) || instance.getContext('experimental-webgl', options);
          }
          return bcd.testOptionParam(createContext, null, 'alpha', true);
        webgl_context.options_desynchronized_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('webgl', options) || instance.getContext('experimental-webgl', options);
          }
          return bcd.testOptionParam(createContext, null, 'desynchronized', true);
        webgl_context.options_failIfMajorPerformanceCaveat_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('webgl', options) || instance.getContext('experimental-webgl', options);
          }
          return bcd.testOptionParam(createContext, null, 'failIfMajorPerformanceCaveat', true);
        webgl_context.options_powerPreference_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('webgl', options) || instance.getContext('experimental-webgl', options);
          }
          return bcd.testOptionParam(createContext, null, 'powerPreference', "default");
        webgl2_context: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          var ctx = instance.getContext('webgl2');
          return !!ctx;
        webgl2_context.options_alpha_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('webgl2', options);
          }
          return bcd.testOptionParam(createContext, null, 'alpha', true, {}, true);
        webgl2_context.options_desynchronized_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('webgl2', options);
          }
          return bcd.testOptionParam(createContext, null, 'desynchronized', true, {}, true);
        webgl2_context.options_failIfMajorPerformanceCaveat_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('webgl2', options);
          }
          return bcd.testOptionParam(createContext, null, 'failIfMajorPerformanceCaveat', true, {}, true);
        webgl2_context.options_powerPreference_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('webgl2', options);
          }
          return bcd.testOptionParam(createContext, null, 'powerPreference', "default", {}, true);
        2d_context: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          var ctx = instance.getContext('2d');
          return !!ctx;
        2d_context.options_alpha_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('2d', options);
          }
          return bcd.testOptionParam(createContext, null, 'alpha', true);
        2d_context.options_colorSpace_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('2d', options);
          }
          return bcd.testOptionParam(createContext, null, 'colorSpace', "srgb");
        2d_context.options_desynchronized_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('2d', options);
          }
          return bcd.testOptionParam(createContext, null, 'desynchronized', true);
        2d_context.options_willReadFrequently_parameter: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          function createContext(options) {
            return instance.getContext('2d', options);
          }
          return bcd.testOptionParam(createContext, null, 'willReadFrequently', true);
        webgpu_context: |-
          bcd.skipIf('Creating a WebGPU context on Safari 16.5 crashes the browser', 'safari', '16.5');

          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          var ctx = instance.getContext('webgpu');
          return !!ctx;
  HTMLCollection:
    __base: var instance = document.forms;
  HTMLContentElement:
    __base: var instance = document.createElement('content');
    __test: return bcd.testObjectName(instance, 'HTMLContentElement');
  HTMLDataElement:
    __base: var instance = document.createElement('data');
    __test: return bcd.testObjectName(instance, 'HTMLDataElement');
  HTMLDataListElement:
    __base: var instance = document.createElement('datalist');
    __test: return bcd.testObjectName(instance, 'HTMLDataListElement');
  HTMLDetailsElement:
    __base: var instance = document.createElement('details');
    __test: return bcd.testObjectName(instance, 'HTMLDetailsElement');
  HTMLDialogElement:
    __base: var instance = document.createElement('dialog');
    __test: return bcd.testObjectName(instance, 'HTMLDialogElement');
  HTMLDirectoryElement:
    __base: var instance = document.createElement('dir');
    __test: return bcd.testObjectName(instance, 'HTMLDirectoryElement');
  HTMLDivElement:
    __base: var instance = document.createElement('div');
    __test: return bcd.testObjectName(instance, 'HTMLDivElement');
  HTMLDListElement:
    __base: var instance = document.createElement('dl');
    __test: return bcd.testObjectName(instance, 'HTMLDListElement');
  HTMLDocument:
    __base: var instance = document;
  HTMLElement:
    __base: var instance = document.createElement('b');
    focus:
      __additional:
        options_focusVisible_parameter: return bcd.testOptionParam(instance, 'focus', 'focusVisible', true);
        options_preventScroll_parameter: return bcd.testOptionParam(instance, 'focus', 'preventScroll', true);
    togglePopover:
      __additional:
        returns_boolean: |-
          if (!('togglePopover' in instance)) {
            return {result: false, message: 'HTMLElement.togglePopover is not defined'};
          }

          document.getElementById('resources').appendChild(instance);
          bcd.addCleanup(function() {
            document.getElementById('resources').removeChild(instance);
          });

          instance.popover = 'auto';
          var value = instance.togglePopover(false);
          return typeof value === 'boolean';
  HTMLEmbedElement:
    __base: var instance = document.createElement('embed');
    __test: return bcd.testObjectName(instance, 'HTMLEmbedElement');
  HTMLFieldSetElement:
    __base: var instance = document.createElement('fieldset');
    __test: return bcd.testObjectName(instance, 'HTMLFieldSetElement');
    __additional:
      elements.type_HTMLCollection: |-
        var els = instance.elements();
        return bcd.testObjectName(els, 'HTMLCollection');
  HTMLFontElement:
    __base: var instance = document.createElement('font');
    __test: return bcd.testObjectName(instance, 'HTMLFontElement');
  HTMLFormControlsCollection:
    __base: |-
      <%api.HTMLFormElement:form%>
      for (var i = 0; i < 3; i++) {
        var input = document.createElement('input');
        input.value = i;
        form.appendChild(input);
      }
      var instance = form.elements;
  HTMLFormElement:
    __base: var instance = document.createElement('form');
    __test: return bcd.testObjectName(instance, 'HTMLFormElement');
  HTMLFrameElement:
    __base: var instance = document.createElement('frame');
    __test: return bcd.testObjectName(instance, 'HTMLFrameElement');
  HTMLFrameSetElement:
    __base: var instance = document.createElement('frameset');
    __test: return bcd.testObjectName(instance, 'HTMLFrameSetElement');
  HTMLHeadElement:
    __base: var instance = document.createElement('head');
    __test: return bcd.testObjectName(instance, 'HTMLHeadElement');
  HTMLHeadingElement:
    __base: var instance = document.createElement('h1');
    __test: return bcd.testObjectName(instance, 'HTMLHeadingElement');
  HTMLHRElement:
    __base: var instance = document.createElement('hr');
    __test: return bcd.testObjectName(instance, 'HTMLHRElement');
  HTMLHtmlElement:
    __base: var instance = document.createElement('html');
    __test: return bcd.testObjectName(instance, 'HTMLHtmlElement');
  HTMLIFrameElement:
    __base: var instance = document.createElement('iframe');
    __test: return bcd.testObjectName(instance, 'HTMLIFrameElement');
    __additional:
      referrerPolicy.no-referrer-when-downgrade: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "no-referrer-when-downgrade";
        return instance.referrerPolicy == "no-referrer-when-downgrade";
      referrerPolicy.origin-when-cross-origin: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "origin-when-cross-origin";
        return instance.referrerPolicy == "origin-when-cross-origin";
      referrerPolicy.unsafe-url: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "unsafe-url";
        return instance.referrerPolicy == "unsafe-url";
  HTMLImageElement:
    __base: var instance = document.createElement('img');
    __test: return bcd.testObjectName(instance, 'HTMLImageElement');
    Image: return bcd.testConstructor('Image');
    __additional:
      referrerPolicy.no-referrer-when-downgrade: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "no-referrer-when-downgrade";
        return instance.referrerPolicy == "no-referrer-when-downgrade";
      referrerPolicy.origin-when-cross-origin: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "origin-when-cross-origin";
        return instance.referrerPolicy == "origin-when-cross-origin";
      referrerPolicy.unsafe-url: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "unsafe-url";
        return instance.referrerPolicy == "unsafe-url";
  HTMLInputElement:
    __base: var instance = document.createElement('input');
    __test: return bcd.testObjectName(instance, 'HTMLInputElement');
  HTMLIsIndexElement:
    __base: var instance = document.createElement('isindex');
    __test: return bcd.testObjectName(instance, 'HTMLIsIndexElement');
  HTMLKeygenElement:
    __base: var instance = document.createElement('keygen');
    __test: return bcd.testObjectName(instance, 'HTMLKeygenElement');
  HTMLLabelElement:
    __base: var instance = document.createElement('label');
    __test: return bcd.testObjectName(instance, 'HTMLLabelElement');
  HTMLLegendElement:
    __base: var instance = document.createElement('legend');
    __test: return bcd.testObjectName(instance, 'HTMLLegendElement');
  HTMLLIElement:
    __base: var instance = document.createElement('li');
    __test: return bcd.testObjectName(instance, 'HTMLLIElement');
  HTMLLinkElement:
    __base: var instance = document.createElement('link');
    __test: return bcd.testObjectName(instance, 'HTMLLinkElement');
    __additional:
      referrerPolicy.no-referrer-when-downgrade: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "no-referrer-when-downgrade";
        return instance.referrerPolicy == "no-referrer-when-downgrade";
      referrerPolicy.origin-when-cross-origin: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "origin-when-cross-origin";
        return instance.referrerPolicy == "origin-when-cross-origin";
      referrerPolicy.unsafe-url: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "unsafe-url";
        return instance.referrerPolicy == "unsafe-url";
  HTMLMapElement:
    __base: var instance = document.createElement('map');
    __test: return bcd.testObjectName(instance, 'HTMLMapElement');
  HTMLMarqueeElement:
    __base: var instance = document.createElement('marquee');
    __test: return bcd.testObjectName(instance, 'HTMLMarqueeElement');
  HTMLMediaElement:
    __base: <%api.HTMLVideoElement:instance%>
    __test: return bcd.testObjectName(instance, 'HTMLVideoElement');
    play:
      __additional:
        returns_promise: |-
          if (!(instance && instance.play)) {
            return {result: false, message: 'instance.play is not defined'};
          }
          var value = instance.play();
          bcd.addCleanup(function() {
            instance.pause();
          });
          return 'then' in value;
  HTMLMenuElement:
    __base: var instance = document.createElement('menu');
    __test: return bcd.testObjectName(instance, 'HTMLMenuElement');
  HTMLMenuItemElement:
    __base: var instance = document.createElement('menuitem');
    __test: return bcd.testObjectName(instance, 'HTMLMenuItemElement');
  HTMLMetaElement:
    __base: var instance = document.createElement('meta');
    __test: return bcd.testObjectName(instance, 'HTMLMetaElement');
  HTMLMeterElement:
    __base: var instance = document.createElement('meter');
    __test: return bcd.testObjectName(instance, 'HTMLMeterElement');
  HTMLModElement:
    __base: var instance = document.createElement('del');
    __test: return bcd.testObjectName(instance, ['HTMLModElement', 'HTMLDelElement']);
  HTMLObjectElement:
    __base: var instance = document.createElement('object');
    __test: return bcd.testObjectName(instance, 'HTMLObjectElement');
  HTMLOListElement:
    __base: var instance = document.createElement('ol');
    __test: return bcd.testObjectName(instance, 'HTMLOListElement');
  HTMLOptGroupElement:
    __base: var instance = document.createElement('optgroup');
    __test: return bcd.testObjectName(instance, 'HTMLOptGroupElement');
  HTMLOptionElement:
    __base: var instance = document.createElement('option');
    __test: return bcd.testObjectName(instance, 'HTMLOptionElement');
    Option: return bcd.testConstructor('Option');
  HTMLOptionsCollection:
    __base: |-
      var el = document.createElement('select');
      for (var i = 0; i < 3; i++) {
        el.appendChild(document.createElement('option'));
      }
      var instance = el.options;
  HTMLOutputElement:
    __base: var instance = document.createElement('output');
    __test: return bcd.testObjectName(instance, 'HTMLOutputElement');
  HTMLParagraphElement:
    __base: var instance = document.createElement('p');
    __test: return bcd.testObjectName(instance, 'HTMLParagraphElement');
  HTMLParamElement:
    __base: var instance = document.createElement('param');
    __test: return bcd.testObjectName(instance, 'HTMLParamElement');
  HTMLPictureElement:
    __base: var instance = document.createElement('picture');
    __test: return bcd.testObjectName(instance, 'HTMLPictureElement');
  HTMLPortalElement:
    __base: var instance = document.createElement('portal');
    __test: return bcd.testObjectName(instance, 'HTMLPortalElement');
  HTMLPreElement:
    __base: var instance = document.createElement('pre');
    __test: return bcd.testObjectName(instance, 'HTMLPreElement');
  HTMLProgressElement:
    __base: var instance = document.createElement('progress');
    __test: return bcd.testObjectName(instance, 'HTMLProgressElement');
  HTMLQuoteElement:
    __base: var instance = document.createElement('blockquote');
    __test: return bcd.testObjectName(instance, ['HTMLQuoteElement', 'HTMLBlockElement', 'HTMLBlockElementConstructor', 'HTMLBlockquoteElement', 'HTMLBlockquoteElementConstructor']);
  HTMLScriptElement:
    __base: var instance = document.createElement('script');
    __test: return bcd.testObjectName(instance, 'HTMLScriptElement');
    __additional:
      referrerPolicy.no-referrer-when-downgrade: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "no-referrer-when-downgrade";
        return instance.referrerPolicy == "no-referrer-when-downgrade";
      referrerPolicy.origin-when-cross-origin: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "origin-when-cross-origin";
        return instance.referrerPolicy == "origin-when-cross-origin";
      referrerPolicy.unsafe-url: |-
        if (!('referrerPolicy' in instance)) {
          return {result: false, message: "instance.referrerPolicy is not defined"}
        }
        instance.referrerPolicy = "unsafe-url";
        return instance.referrerPolicy == "unsafe-url";
  HTMLSelectElement:
    __base: var instance = document.createElement('select');
    __test: return bcd.testObjectName(instance, 'HTMLSelectElement');
    add:
      __additional:
        index_before_parameter: |-
          var opt1 = document.createElement("option");
          opt1.value = "1";
          opt1.text = "Option: Value 1";
          instance.add(opt1);

          var opt2 = document.createElement("option");
          opt2.value = "2";
          opt2.text = "Option: Value 2";
          instance.add(opt2);

          var opt3 = document.createElement("option");
          opt3.value = "3";
          opt3.text = "Option: Value 3";

          try {
            instance.add(opt3, 1);

            return instance.options[1] === opt3;
          } catch(e) {
            return {result: false, message: e.message};
          }
  HTMLShadowElement:
    __base: var instance = document.createElement('shadow');
    __test: return bcd.testObjectName(instance, 'HTMLShadowElement');
  HTMLSlotElement:
    __base: var instance = document.createElement('slot');
    __test: return bcd.testObjectName(instance, 'HTMLSlotElement');
  HTMLSourceElement:
    __base: var instance = document.createElement('source');
    __test: return bcd.testObjectName(instance, 'HTMLSourceElement');
  HTMLSpanElement:
    __base: var instance = document.createElement('span');
    __test: return bcd.testObjectName(instance, 'HTMLSpanElement');
  HTMLStyleElement:
    __base: var instance = document.createElement('style');
    __test: return bcd.testObjectName(instance, 'HTMLStyleElement');
  HTMLTableCaptionElement:
    __base: var instance = document.createElement('caption');
    __test: return bcd.testObjectName(instance, 'HTMLTableCaptionElement');
  HTMLTableCellElement:
    __base: var instance = document.createElement('td');
    __test: return bcd.testObjectName(instance, ['HTMLTableCellElement', 'HTMLTableDataCellElement']);
  HTMLTableColElement:
    __base: var instance = document.createElement('col');
    __test: return bcd.testObjectName(instance, 'HTMLTableColElement');
  HTMLTableElement:
    __base: var instance = document.createElement('table');
    __test: return bcd.testObjectName(instance, 'HTMLTableElement');
  HTMLTableRowElement:
    __base: var instance = document.createElement('tr');
    __test: return bcd.testObjectName(instance, 'HTMLTableRowElement');
    insertCell:
      __additional:
        index_parameter_optional: |-
          if (!(instance && instance.insertCell)) {
            return {result: false, message: 'instance.insertCell is not defined'};
          }
          try {
            instance.insertCell();
            return true;
          } catch(e) {
            if (stringIncludes(e.message, ['WRONG_ARGUMENTS_ERR', 'Not enough arguments'])) {
              return {result: false, message: e.message};
            }
            return e;
          }
  HTMLTableSectionElement:
    __base: var instance = document.createElement('tbody');
    __test: return bcd.testObjectName(instance, 'HTMLTableSectionElement');
  HTMLTemplateElement:
    __base: var instance = document.createElement('template');
    __test: return bcd.testObjectName(instance, 'HTMLTemplateElement');
  HTMLTextAreaElement:
    __base: var instance = document.createElement('textarea');
    __test: return bcd.testObjectName(instance, 'HTMLTextAreaElement');
  HTMLTimeElement:
    __base: var instance = document.createElement('time');
    __test: return bcd.testObjectName(instance, 'HTMLTimeElement');
  HTMLTitleElement:
    __base: var instance = document.createElement('title');
    __test: return bcd.testObjectName(instance, 'HTMLTitleElement');
  HTMLTrackElement:
    __base: var instance = document.createElement('track');
    __test: return bcd.testObjectName(instance, 'HTMLTrackElement');
  HTMLUListElement:
    __base: var instance = document.createElement('ul');
    __test: return bcd.testObjectName(instance, 'HTMLUListElement');
  HTMLUnknownElement:
    __base: var instance = document.createElement('unknown');
    __test: return bcd.testObjectName(instance, 'HTMLUnknownElement');
  HTMLVideoElement:
    __base: var instance = document.createElement('video');
    __test: return bcd.testObjectName(instance, 'HTMLVideoElement');
  IDBDatabase:
    __base: |-
      <%api.IDBOpenDBRequest:req%>
      req.onsuccess = function() {
        callback(req.result);
      };
      req.onerror = function(event) {
        fail(event.message);
      };
  IDBFactory:
    __base: var instance = self.indexedDB || self.mozIndexedDB || self.webkitIndexedDB || self.msIndexedDB;
  IDBOpenDBRequest:
    __base: |-
      <%api.IDBFactory:idb%>
      var instance = idb.open("collector");
  IDBRequest:
    __base: <%api.IDBOpenDBRequest:instance%>
  IDBVersionChangeEvent:
    __base: |-
      var instance;
      try {
        instance = new IDBVersionChangeEvent('upgradeneeded');
      } catch(e) {
        try {
          instance = document.createEvent('IDBVersionChangeEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  IIRFilterNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createIIRFilter' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createIIRFilter is not defined'};
      }
      var instance = reusableInstances.audioContext.createIIRFilter([1], [1]);
  ImageBitmap:
    __resources:
      - image-black
    __base: |-
      if (!('document' in self)) {
        // XXX Implement worker tests for ImageBitmap
        return {result: null, message: 'Testing ImageBitmap in workers is not yet implemented'};
      }
      if (!('createImageBitmap' in self)) {
        return {result: false, message: 'Cannot create image bitmap'};
      }
      var promise = createImageBitmap(document.getElementById('resource-image-black'));
  ImageBitmapRenderingContext:
    __base: |-
      if (!('document' in self)) {
        // XXX Implement worker tests for ImageBitmapRenderingContext
        return {result: null, message: 'Testing ImageBitmapRenderingContext in workers is not yet implemented'};
      }
      var canvas = document.createElement('canvas');
      if (!canvas) {
        return {result: false, message: 'Could not create canvas element'};
      };
      var instance = canvas.getContext('bitmaprenderer');
  ImageCapture:
    __base: |-
      <%api.MediaDevices:mediaDevices%>
      if (!('ImageCapture' in self)) {
        return {result: false, message: 'ImageCapture is not defined'};
      }
      var stream = mediaDevices.getUserMedia({video: true});
      stream.then(function() {});
      var promise = stream.then(function(s) {
        var tracks = s.getVideoTracks();
        return new ImageCapture(tracks[0]);
      });
  ImageData:
    __base: |-
      var instance;
      if ('ImageData' in self) {
        instance = new ImageData(5, 5);
      } else if ('document' in self) {
        <%api.CanvasRenderingContext2D:ctx%>
        instance = ctx.createImageData(16, 16);
      }
  InkPresenter:
    __base: |-
      if (!('ink' in navigator)) {
        return {result: false, message: 'navigator.ink is not defined'};
      }
      if (!('requestPresenter' in navigator.ink)) {
        return {result: false, message: 'navigator.ink.requestPresenter() is not defined'};
      }
      var promise = navigator.ink.requestPresenter();
  InputDeviceInfo:
    __base: |-
      <%api.MediaDevices:mediaDevices%>
      var promise = navigator.mediaDevices.enumerateDevices().then(
        function(devices) {
          for (var i = 0; i < devices.length; i++) {
            if (devices[i].kind == 'audioinput' || devices[i].kind == 'videoinput') {
              return devices[i];
            }
          }
        }
      );
  InputEvent:
    __base: |-
      if (!('InputEvent' in self)) {
        return {result: false, message: 'InputEvent is not defined'}
      }
      var instance = new InputEvent('input');
  InstallEvent:
    __base: |-
      // During the installation of the service worker, we set an "installEvent" global variable so that we may easily reuse it here:
      //   var installEvent = null;
      //   self.addEventListener('install', function (event) {
      //     installEvent = event;
      //   });

      var instance = installEvent;
  IntersectionObserver:
    IntersectionObserver:
      __additional:
        options_root_parameter_Document: |-
          if (!('IntersectionObserver' in self)) {
            return {result: false, message: 'IntersectionObserver is not defined'}
          }
          try {
            new IntersectionObserver(function() {}, {root: document});
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
  InterventionReportBody:
    __base: |-
      // XXX Obtaining an instance of this interface is much like triggering an event.
      // See http://developer.mozilla.org/docs/Web/API/InterventionReportBody#examples
      return {result: null, message: 'Testing InterventionReportBody is not yet implemented'};
    toJSON: return null;
  KeyboardEvent:
    __base: |-
      var instance;
      try {
        instance = new KeyboardEvent('keypress');
      } catch(e) {
        try {
          instance = document.createEvent('KeyboardEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  KHR_parallel_shader_compile:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('KHR_parallel_shader_compile');
  Location:
    __base: var instance = location;
    toString: |-
      if (!('toString' in instance)) {
        return {result: false, message: 'toString is not defined'};
      }
      return instance.toString() == instance.href;
  MediaCapabilities:
    __base: var instance = navigator.mediaCapabilities;
  MediaDeviceInfo:
    __base: |-
      <%api.MediaDevices:mediaDevices%>
      var promise = navigator.mediaDevices.enumerateDevices().then(
        function(devices) {
          return devices[0];
        }
      );
  MediaDevices:
    __base: var instance = navigator.mediaDevices;
  MediaElementAudioSourceNode:
    __resources:
      - audio-blip
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createMediaElementSource' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createMediaElementSource is not defined'};
      }
      var el = document.getElementById('resource-audio-blip');
      // Element is cloned for each test because only one audio source node can be associated with an element
      var clone = el.cloneNode(true);
      var instance = reusableInstances.audioContext.createMediaElementSource(clone);
  MediaEncryptedEvent:
    __base: |-
      if (!('MediaEncryptedEvent' in self)) {
        return {result: false, message: 'MediaEncryptedEvent is not defined'};
      }
      var instance = new MediaEncryptedEvent('encrypted');
  MediaKeyMessageEvent:
    __base: |-
      if (!('MediaKeyMessageEvent' in self)) {
        return {result: false, message: 'MediaKeyMessageEvent is not defined'};
      }
      var instance = new MediaKeyMessageEvent('license-request', {message: new ArrayBuffer(), messageType: 'license-request'});
  MediaList:
    __resources:
      - createStyleSheet
    __base: |-
      var stylesheet = reusableInstances.createStyleSheet('@media (max-width: 600px) {body {background-color: #111;color: white;}}');
      var instance = stylesheet.media;
  MediaQueryList:
    __base: "var instance = window.matchMedia('screen and max-width: 800px;');"
    __additional:
      EventTarget_inheritance: return !!instance && 'addEventListener' in instance;
  MediaQueryListEvent:
    __base: |-
      if (!('MediaQueryListEvent' in self)) {
        return {result: false, message: 'MediaQueryListEvent is not defined'};
      }
      var instance = new MediaQueryListEvent('change');
  MediaRecorder:
    __resources:
      - mediaStream
    __base: |-
      if (!reusableInstances.mediaStream) {
        return {result: false, message: 'Media stream is not available'};
      }
      if (!('MediaRecorder' in self)) {
        return {result: false, message: 'MediaRecorder is not defined'}
      }
      var instance = new MediaRecorder(reusableInstances.mediaStream);
    MediaRecorder:
      __resources:
      __additional:
        options_parameter: |-
          function construct(options) {
            new MediaRecorder(reusableInstances.mediaStream, options);
          }
          return bcd.testOptionParam(construct, null, 'mimeType', '');
  MediaSession:
    __base: var instance = navigator.mediaSession;
  MediaSource:
    __base: |-
      if (!('MediaSource' in self)) {
        return {result: false, message: 'MediaSource is not defined'};
      }
      var instance = new MediaSource();
    isTypeSupported: return 'isTypeSupported' in MediaSource;
  MediaStream:
    __resources:
      - mediaStream
    __base: |-
      var instance = reusableInstances.mediaStream;
  MediaStreamAudioDestinationNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createMediaStreamDestination' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createMediaStreamDestination is not defined'};
      }
      var instance = reusableInstances.audioContext.createMediaStreamDestination();
  MediaStreamAudioSourceNode:
    __resources:
      - audioContext
      - mediaStream
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!reusableInstances.mediaStream) {
        return {result: false, message: 'Media stream is not available'};
      }
      if (!('createMediaStreamSource' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createMediaStreamSource is not defined'};
      }
      var instance = reusableInstances.audioContext.createMediaStreamSource(reusableInstances.mediaStream);
  MediaStreamEvent:
    __resources:
      - mediaStream
    __base: |-
      if (!reusableInstances.mediaStream) {
        return {result: false, message: 'Media stream is not available'};
      }

      var instance;
      try {
        instance = new MediaStreamEvent('addstream', { stream: reusableInstances.mediaStream });
      } catch(e) {
        try {
          instance = document.createEvent('MediaStreamEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: e.message};
          }
          throw e;
        }
      }
  MediaStreamTrack:
    __resources:
      - mediaStream
    __base: |-
      if (!reusableInstances.mediaStream) {
        return {result: false, message: 'Media stream is not available'};
      }
      var instance = reusableInstances.mediaStream.getAudioTracks()[0];
  MediaStreamTrackEvent:
    __base: |-
      <%api.MediaStreamTrack:msTrack%>

      var instance;
      try {
        instance = new MediaStreamTrackEvent('addtrack', { track: msTrack });
      } catch(e) {
        try {
          instance = document.createEvent('MediaStreamTrackEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: e.message};
          }
          throw e;
        }
      }
  MediaStreamTrackAudioSourceNode:
    __resources:
      - audioContext
    __base: |-
      <%api.MediaStreamTrack:msTrack%>
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createMediaStreamTrackSource' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createMediaStreamTrackSource is not defined'};
      }
      var instance = reusableInstances.audioContext.createMediaStreamTrackSource(msTrack);
  MerchantValidationEvent:
    __base: |-
      if (!('MerchantValidationEvent' in self)) {
        return {result: false, message: 'MerchantValidationEvent is not defined'};
      }
      var instance = new MerchantValidationEvent('merchantvalidation');
  MessageEvent:
    __base: |-
      var instance;
      try {
        instance = new MessageEvent('message');
      } catch(e) {
        try {
          instance = document.createEvent('MessageEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  MessageChannel:
    __base: |-
      if (!('MessageChannel' in self)) {
        return {result: false, message: 'MessageChannel is not defined'};
      }
      var instance = new MessageChannel();
  MessagePort:
    __base: |-
      <%api.MessageChannel:channel%>
      var instance = channel.port1;
  Metadata:
    __base: |-
      <%api.FileSystemEntry:fseCallback%>
      function fseCallback(fse) {
        fse.getMetadata(callback, fail);
      }
  MimeType:
    __base: |-
      <%api.MimeTypeArray:mimetypes%>
      if (mimetypes.length === 0) {
        return {result: null, message: 'navigator.mimeTypes is an empty array'};
      }
      var instance = mimeTypes[0];
  MimeTypeArray:
    __base: |-
      if (!('mimeTypes' in navigator)) {
        return {result: false, message: 'navigator.mimeTypes is not defined'};
      }
      var instance = navigator.mimeTypes;
  MouseEvent:
    __base: |-
      var instance;
      try {
        instance = new MouseEvent('click');
      } catch(e) {
        try {
          instance = document.createEvent('MouseEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  MutationEvent:
    __base: |-
      try {
        var instance = document.createEvent('MutationEvent');
      } catch(e) {
        if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
          return {result: false, message: 'Cannot create event'};
        }
        throw e;
      }
  MutationObserver:
    __base: |-
      var constructor = window.MutationObserver || window.WebKitMutationObserver;
      if (!constructor) {
        return {result: false, message: '(WebKit)MutationObserver is not defined'};
      };
      var instance = new constructor(function(mutations){});
  MutationRecord:
    __base: |-
      <%api.MutationObserver:observer%>

      // Create element and observe
      var targetNode = document.createElement('p');
      observer.observe(targetNode, {
        childList: true,
        attributes: true
      });

      // Make a change
      targetNode.innerHTML = "foo bar";

      // Get the record
      var records = observer.takeRecords();
      var instance = records[0];

      // Finally, disconnect the observer
      observer.disconnect();
  NamedNodeMap:
    __base: var instance = document.body.attributes;
  Navigator:
    __base: var instance = navigator;
  Node:
    __base: var instance = document;
  NodeList:
    __base: var instance = document.childNodes;
  NodeIterator:
    __base: var instance = document.createNodeIterator(document);
  Notification:
    __base: |-
      if (!('Notification' in self)) {
        return {result: false, message: 'Notification is not defined'};
      }
      var instance = new Notification('');
  NotificationEvent:
    __base: |-
      <%api.Notification:notification%>
      if (!('NotificationEvent' in self)) {
        return {result: false, message: 'NotificationEvent is not defined'};
      }
      var instance = new NotificationEvent('notificationclick', {notification});
  OfflineAudioCompletionEvent:
    __resources:
      - audioContext
    __base: |-
      <%api.AudioBuffer:buffer%>
      if (!('OfflineAudioCompletionEvent' in self)) {
        return {result: false, message: 'OfflineAudioCompletionEvent is not defined'};
      }
      var instance = new OfflineAudioCompletionEvent('complete', {renderedBuffer: buffer});
  OfflineAudioContext:
    __resources:
      - offlineAudioContext
    __base: var instance = reusableInstances.offlineAudioContext;
    __test: return 'OfflineAudioContext' in self;
    startRendering:
      __additional:
        returns_promise: |-
          if (!(instance && instance.startRendering)) {
            return {result: false, message: 'instance.startRendering is not defined'};
          }
          var value = instance.startRendering();
          return 'then' in value;
  OscillatorNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createOscillator' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createOscillator is not defined'};
      }
      var instance = reusableInstances.audioContext.createOscillator();
  OES_draw_buffers_indexed:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('OES_draw_buffers_indexed');
  OES_element_index_uint:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_element_index_uint');
  OES_fbo_render_mipmap:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_fbo_render_mipmap');
  OES_standard_derivatives:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_standard_derivatives');
  OES_texture_float:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_texture_float');
  OES_texture_float_linear:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('OES_texture_float_linear');
  OES_texture_half_float:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_texture_half_float');
  OES_texture_half_float_linear:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_texture_half_float_linear');
  OES_vertex_array_object:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('OES_vertex_array_object');
  OVR_multiview2:
    __resources:
      - webGL2
    __base: |-
      if (!reusableInstances.webGL2) {
        return {result: false, message: 'WebGL 2 is not available'};
      };
      var instance = reusableInstances.webGL2.getExtension('OVR_multiview2');
  OffscreenCanvas:
    __base: var instance = new OffscreenCanvas(1024, 1024);
    getContext:
      __additional:
        bitmaprenderer_context: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          var ctx = instance.getContext('bitmaprenderer');
          return !!ctx;
        webgl_context: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          var ctx = instance.getContext('webgl');
          return !!ctx;
        webgl2_context: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          var ctx = instance.getContext('webgl2');
          return !!ctx;
        webgpu_context: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          var ctx = instance.getContext('webgpu');
          return !!ctx;
        2d_context: |-
          if (!(instance && instance.getContext)) {
            return {result: false, message: 'instance.getContext is not defined'};
          }
          var ctx = instance.getContext('2d');
          return !!ctx;
    __additional:
      convertToBlob.option_type_parameter_webp: |-
        instance.getContext('2d');
        if (!('convertToBlob' in instance)) {
          return {result: false, message: "instance.convertToBlob is not defined"}
        }
        var blobPromise = instance.convertToBlob({type: 'image/webp'});
        return blobPromise.then(function (blob) {
          return blob.type === 'image/webp';
        });
  PageTransitionEvent:
    __base: |-
      var instance;
      try {
        instance = new PageTransitionEvent('pageshow');
      } catch(e) {
        try {
          instance = document.createEvent('PageTransitionEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  PaintWorklet:
    __base: var instance = CSS.paintWorklet;
  PannerNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createPanner' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createPanner is not defined'};
      }
      var instance = reusableInstances.audioContext.createPanner();
  Path2D:
    __base: |-
      if (!('Path2D' in self)) {
        return {result: false, message: 'Path2D is not defined'};
      }
      var instance = new Path2D();
  Performance:
    __base: |-
      if (!('performance' in self)) {
        return {result: false, message: 'performance is not defined'};
      };
      var instance = performance;
    mark:
      __additional:
        markOptions_parameter: |-
          if (!(instance && instance.mark)) {
            return {result: false, message: 'instance.mark is not defined'};
          }
          function mark(options) {
            instance.mark('foo', options);
          }
          return bcd.testOptionParam(mark, null, 'detail', 'bar');
        returns_performancemark: return !!instance.mark('foo');
    measure:
      __additional:
        measureOptions_parameter: |-
          if (!(instance && instance.measure)) {
            return {result: false, message: 'instance.measure is not defined'};
          }
          function measure(options) {
            instance.measure('foo', options);
          }
          return bcd.testOptionParam(measure, null, 'detail', 'bar', {'start': 0});
        returns_performancemeasure: return !!instance.measure('foo');
  PerformanceEntry:
    __base: |-
      <%api.Performance:prf%>
      if (!('getEntries' in prf)) {
        return {result: false, message: 'performance.getEntries is not defined'};
      }
      var instance = prf.getEntries()[0];
    toJSON: return !!instance && 'toJSON' in instance;
  PerformanceMark:
    __base: |-
      <%api.Performance:prf%>
      if (!('mark' in prf)) {
        return {result: false, message: 'performance.mark is not defined'};
      };
      performance.mark('mark');
      var instance = performance.getEntriesByName('mark')[0];
  PerformanceNavigation:
    __base: |-
      <%api.Performance:prf%>
      var instance = performance.navigation;
  PerformanceObserver:
    __additional:
      PerformanceObserver.droppedEntriesCount: |-
        // Using the "completed" variable ensures the callback isn't run multiple times
        var completed = false;

        function perfObserver(entries, observer, droppedEntriesCount) {
          if (!completed) {
            success(typeof droppedEntriesCount != "undefined");
            completed = true;
          }
        }

        var observer = new PerformanceObserver(perfObserver);
        observer.observe({ type: "resource", buffered: true });

        bcd.addCleanup(function() {
          observer.disconnect();  
        });

        return 'callback';
  PerformanceResourceTiming:
    __base: var instance = performance.getEntriesByType("resource")[0];
  PerformanceTiming:
    __base: |-
      <%api.Performance:prf%>
      var instance = performance.timing;
  PeriodicWave:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      var real = new Float32Array(2);
      var imag = new Float32Array(2);
      var instance = reusableInstances.audioContext.createPeriodicWave(real, imag);
  PermissionsPolicyViolationReportBody:
    __base: |-
      // XXX Obtaining an instance of this interface is much like triggering an event.
      // See http://developer.mozilla.org/docs/Web/API/PermissionsPolicyViolationReportBody#examples
      return {result: null, message: 'Testing PermissionsPolicyViolationReportBody is not yet implemented'};
  Plugin:
    __base: |-
      if (!navigator.plugins.length) {
        throw new Error('navigator.plugins is empty');
      }
      var instance = navigator.plugins[0];
  PluginArray:
    __base: var instance = navigator.plugins;
  PopStateEvent:
    __base: |-
      var instance;
      try {
        instance = new PopStateEvent('popstate');
      } catch(e) {
        try {
          instance = document.createEvent('PopStateEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  ProcessingInstruction:
    __base: |-
      <%api.DOMParser:parser%>
      var doc = parser.parseFromString('<foo />', 'application/xml');
      var instance = doc.createProcessingInstruction('xml-stylesheet', 'href="mycss.css" type="text/css"');
  ProgressEvent:
    __base: |-
      var instance;
      try {
        instance = new ProgressEvent('progress');
      } catch(e) {
        try {
          instance = document.createEvent('ProgressEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  PushEvent:
    __base: |-
      if (!('PushEvent' in self)) {
        return {result: false, message: 'PushEvent is not defined'};
      }
      var instance = new PushEvent('push');
  RadioNodeList:
    __base: |-
      <%api.HTMLFormElement:form%>
      for (var i = 0; i < 3; i++) {
        var input = document.createElement('input');
        input.value = i;
        input.type = "radio";
        input.name = "radio";
        form.appendChild(input);
      }
      var instance = form.elements.namedItem('radio');
  Range:
    __base: var instance = document.createRange();
    collapse:
      __additional:
        toStart_parameter_optional: |-
          if (!(instance && instance.collapse)) {
            return {result: false, message: 'instance.collapse is not defined'};
          }
          try {
            instance.collapse();
            return true;
          } catch(e) {
            if (e instanceof TypeError || stringIncludes(e.message, ['WRONG_ARGUMENTS_ERR', 'Not enough arguments'])) {
              return {result: false, message: e.message};
            }
            return e;
          }
  ReadableStream:
    __base: |-
      if (!('fetch' in self)) {
        return {result: false, message: 'fetch is not defined'};
      }
      var promise = fetch('/favicon/favicon.ico').then(function(response) {
        return response.body;
      });
  ReadableStreamDefaultController:
    __base: |-
      if (!('ReadableStream' in self)) {
        return {result: false, message: 'ReadableStream constructor is not defined'};
      }

      var instance;
      var stream = new ReadableStream({
        start(controller) {
          instance = controller;
        }
      });
  ReadableStreamDefaultReader:
    __base: |-
      <%api.ReadableStream:streamPromise%>
      var promise = streamPromise.then(function(stream) {
        return stream.getReader();
      });
  Report:
    __base: |-
      // XXX Obtaining an instance of this interface is much like triggering an event.
      // See http://developer.mozilla.org/docs/Web/API/Report#examples
      return {result: null, message: 'Testing Report is not yet implemented'};
    toJSON: return null;
  ReportBody:
    __base: |-
      // XXX Obtaining an instance of this interface is much like triggering an event.
      // See http://developer.mozilla.org/docs/Web/API/ReportBody#examples
      return {result: null, message: 'Testing ReportBody is not yet implemented'};
    toJSON: return null;
  Request:
    __base: |-
      if (!('Request' in self)) {
        return {result: false, message: 'Request is not defined'};
      }
      var instance = new Request('');
    Request:
      __additional:
        init_priority_parameter: |-
          function construct(options) {
            new Request('', options);
          }
          return bcd.testOptionParam(construct, null, 'priority', 'auto');
        init_referrer_parameter: |-
          function construct(options) {
            new Request('', options);
          }
          return bcd.testOptionParam(construct, null, 'referrer', 'no-referrer');
    cache:
      __additional:
        only-if-cached: |-
          instance = new Request('/favicon/favicon.ico', {mode: "same-origin", cache: "only-if-cached"});
          return instance.cache === "only-if-cached";
    credentials:
      __additional:
        default_same-origin: return instance.credentials === "same-origin";
  ResizeObserver:
    __base: |-
      if (!('ResizeObserver' in self)) {
        return {result: false, message: 'ResizeObserver is not defined'}
      }
      var instance = new ResizeObserver(function() {});
    observe:
      __additional:
        options_box_parameter: |-
          <%api.Element:el%>
          if (!('observe' in instance)) {
            return {result: false, message: 'ResizeObserver.observe is not defined'}
          }
          function observe(options) {
            instance.observe(el, options);
          }
          return bcd.testOptionParam(observe, null, 'box', 'content-box');
  Response:
    __base: |-
      if (!('Response' in self)) {
        return {result: false, message: 'Response is not defined'};
      }
      var instance = new Response('');
    Response:
      __additional:
        accept_readablestream: |-
          <%api.ReadableStream:rsPromise%>
          return rsPromise.then(function(readableStream) {
            try {
              new Response(readableStream);
              return true;
            } catch(e) {
              return {result: false, message: e.message};
            }
          });
        body_parameter_optional: |-
          try {
            new Response();
            return true;
          } catch(e) {
            if (e instanceof TypeError || stringIncludes(e.message, ['WRONG_ARGUMENTS_ERR', 'Not enough arguments'])) {
              return {result: false, message: e.message};
            }
            return e;
          }
    body:
      __additional:
        readable_byte_stream: |-
          return !!instance.body && 'getReader' in instance.body;
    __additional:
      json_static: |-
        return 'Response' in self && 'json' in Response;
  RTCDataChannel:
    __base: |-
      <%api.RTCPeerConnection:connection%>
      var instance = connection.createDataChannel('channel');
    binaryType:
      __additional:
        arraybuffer_value: |-
          try {
            instance.binaryType = 'arraybuffer';
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
        blob_value: |-
          try {
            instance.binaryType = 'blob';
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
  RTCDataChannelEvent:
    __base: |-
      <%api.RTCDataChannel:channel%>
      if (!('RTCDataChannelEvent' in self)) {
        return {result: false, message: 'RTCDataChannelEvent is not defined'};
      }
      var instance = new RTCDataChannelEvent('datachannel', {channel: channel});
  RTCDTMFToneChangeEvent:
    __base: |-
      if (!('RTCDTMFToneChangeEvent' in self)) {
        return {result: false, message: 'RTCDTMFToneChangeEvent is not defined'};
      }
      var instance = new RTCDTMFToneChangeEvent('tonechange', {tone: ''});
  RTCIceCandidate:
    __base: "var instance = new RTCIceCandidate({candidate: 'candidate:4234997325 1 udp 2043278322 192.168.0.56 44323 typ host', sdpMid: ''});"
  RTCIdentityAssertion:
    __base: |-
      <%api.RTCPeerConnection:rpc%>
      if (!('getIdentityAssertion' in rpc)) {
        return {result: false, message: 'RTCPeerConnection.prototype.getIdentityAssertion is not defined'};
      }
      var promise = rpc.getIdentityAssertion();
  RTCPeerConnection:
    __base: |-
      /* Firefox briefly defines RTCPeerConnection in older versions, but it is not a valid constructor until later versions. */
      var constructor = window.mozRTCPeerConnection || window.RTCPeerConnection || window.webkitRTCPeerConnection;
      if (!constructor) {
        return {result: false, message: '(moz/webkit)RTCPeerConnection is not defined or is falsy'};
      };
      var instance = new constructor({iceServers: []});
    RTCPeerConnection:
      __additional:
        configuration_bundlePolicy_parameter: return bcd.testOptionParam(constructor, 'constructor', 'bundlePolicy', 'balanced');
        configuration_certificates_parameter: return bcd.testOptionParam(constructor, 'constructor', 'certificates', []);
        configuration_iceCandidatePoolSize_parameter: return bcd.testOptionParam(constructor, 'constructor', 'iceCandidatePoolSize', 0);
        configuration_iceServers_parameter: return bcd.testOptionParam(constructor, 'constructor', 'iceServers', []);
        configuration_iceTransportPolicy_parameter: return bcd.testOptionParam(constructor, 'constructor', 'iceTransportPolicy', 'all');
        configuration_peerIdentity_parameter: return bcd.testOptionParam(constructor, 'constructor', 'peerIdentity', 'foobar');
        configuration_rtcpMuxPolicy_parameter: return bcd.testOptionParam(constructor, 'constructor', 'rtcpMuxPolicy', 'negotiate');
    addIceCandidate:
      __additional:
        returns_promise: |-
          <%api.RTCIceCandidate:candidate%>
          if (!(instance && instance.addIceCandidate)) {
            return {result: false, message: 'instance.addIceCandidate is not defined'};
          }
          var value = instance.addIceCandidate(candidate);
          return 'then' in value;
    addTransceiver:
      __additional:
        init_direction_parameter: |-
          if (!(instance && instance.addTransceiver)) {
            return {result: false, message: 'instance.addTransceiver is not defined'};
          }
          function addTransceiver(init) {
            instance.addTransceiver("audio", init)
          }
          return bcd.testOptionParam(addTransceiver, null, "direction", "sendrecv");
        init_sendEncodings_parameter: |-
          if (!(instance && instance.addTransceiver)) {
            return {result: false, message: 'instance.addTransceiver is not defined'};
          }
          function addTransceiver(init) {
            instance.addTransceiver("audio", init)
          }
          return bcd.testOptionParam(addTransceiver, null, "sendEncodings", [{maxBitrate: 44100}]);
    createAnswer:
      __additional:
        returns_promise: |-
          if (!(instance && instance.createAnswer)) {
            return {result: false, message: 'instance.createAnswer is not defined'};
          }
          var value = instance.createAnswer();
          return 'then' in value;
    createOffer:
      __additional:
        returns_promise: |-
          if (!(instance && instance.createOffer)) {
            return {result: false, message: 'instance.createOffer is not defined'};
          }
          var value = instance.createOffer();
          return 'then' in value;
    getStats:
      __additional:
        returns_promise: |-
          if (!(instance && instance.getStats)) {
            return {result: false, message: 'instance.getStats is not defined'};
          }
          var value = instance.getStats();
          return 'then' in value;
    setLocalDescription:
      __additional:
        description_parameter_optional: |-
          if (!(instance && instance.setLocalDescription)) {
            return {result: false, message: 'instance.setLocalDescription is not defined'};
          }
          return instance.setLocalDescription().then(function() {return true}).catch(function(e) {
            if (e instanceof TypeError || stringIncludes(e.message, ['WRONG_ARGUMENTS_ERR', 'Not enough arguments'])) {
              return {result: false, message: e.message};
            }
            return e;
          });
        returns_promise: |-
          <%api.RTCSessionDescription:description%>
          if (!(instance && instance.setLocalDescription)) {
            return {result: false, message: 'instance.setLocalDescription is not defined'};
          }
          var value = instance.setLocalDescription(description);
          if ('then' in value) {
            value.catch(function() {});
            return true;
          }
          return false;
    setRemoteDescription:
      __additional:
        returns_promise: |-
          <%api.RTCSessionDescription:description%>
          if (!(instance && instance.setRemoteDescription)) {
            return {result: false, message: 'instance.setRemoteDescription is not defined'};
          }
          var value = instance.setRemoteDescription(description);
          if ('then' in value) {
            value.catch(function() {});
            return true;
          }
          return false;
  RTCSessionDescription:
    __base: "var instance = new RTCSessionDescription({type: 'offer'});"
  RTCStatsReport:
    __resources:
      - rtcStats
    __base: |-
      if (reusableInstances.rtcStats === 'callback' || reusableInstances.rtcStats === null) {
        return {result: null, message: "Could not generate RTC stats in time"};
      } else if (!reusableInstances.rtcStats) {
        return {result: false, message: "Could not generate RTC stats"};
      }

      // The following object is created for easy access to individual stats entries
      var stats = Array.from(reusableInstances.rtcStats.values());

      // The following function is defined to help obtain individual stats types
      // and entries
      function getStatByType(type, entry) {
        for (var i = 0; i < stats.length; i++) {
          if (stats[i].type === type) {
            if (!entry || !!stats[i][entry]) {
              return stats[i];
            }
          }
        }

        return false;
      }

      var instance = reusableInstances.rtcStats;

      // XXX There's a lot of issues with these tests
      return {result: null, message: "These tests have been disabled due to too many issues. They will be re-enabled once the issues have been resolved."};
    __additional:
      type_candidate-pair: return !!getStatByType('candidate-pair');
      type_candidate-pair.availableIncomingBitrate: |-
        return {result: null, message: 'Untestable property'};
        return !!getStatByType('candidate-pair', 'availableIncomingBitrate');
      type_candidate-pair.availableOutgoingBitrate: return !!getStatByType('candidate-pair', 'availableOutgoingBitrate');
      type_candidate-pair.bytesDiscardedOnSend: return !!getStatByType('candidate-pair', 'bytesDiscardedOnSend');
      type_candidate-pair.bytesReceived: return !!getStatByType('candidate-pair', 'bytesReceived');
      type_candidate-pair.bytesSent: return !!getStatByType('candidate-pair', 'bytesSent');
      type_candidate-pair.consentRequestsSent: return !!getStatByType('candidate-pair', 'consentRequestsSent');
      type_candidate-pair.currentRoundTripTime: return !!getStatByType('candidate-pair', 'currentRoundTripTime');
      type_candidate-pair.id: return !!getStatByType('candidate-pair', 'id');
      type_candidate-pair.lastPacketReceivedTimestamp: return !!getStatByType('candidate-pair', 'lastPacketReceivedTimestamp');
      type_candidate-pair.lastPacketSentTimestamp: return !!getStatByType('candidate-pair', 'lastPacketSentTimestamp');
      type_candidate-pair.localCandidateId: return !!getStatByType('candidate-pair', 'localCandidateId');
      type_candidate-pair.nominated: return !!getStatByType('candidate-pair', 'nominated');
      type_candidate-pair.packetsDiscardedOnSend: return !!getStatByType('candidate-pair', 'packetsDiscardedOnSend');
      type_candidate-pair.packetsReceived: return !!getStatByType('candidate-pair', 'packetsReceived');
      type_candidate-pair.packetsSent: return !!getStatByType('candidate-pair', 'packetsSent');
      type_candidate-pair.priority: return !!getStatByType('candidate-pair', 'priority');
      type_candidate-pair.remoteCandidateId: return !!getStatByType('candidate-pair', 'remoteCandidateId');
      type_candidate-pair.requestsReceived: return !!getStatByType('candidate-pair', 'requestsReceived');
      type_candidate-pair.requestsSent: return !!getStatByType('candidate-pair', 'requestsSent');
      type_candidate-pair.responsesReceived: return !!getStatByType('candidate-pair', 'responsesReceived');
      type_candidate-pair.responsesSent: return !!getStatByType('candidate-pair', 'responsesSent');
      type_candidate-pair.state: return !!getStatByType('candidate-pair', 'state');
      type_candidate-pair.timestamp: return !!getStatByType('candidate-pair', 'timestamp');
      type_candidate-pair.totalRoundTripTime: return !!getStatByType('candidate-pair', 'totalRoundTripTime');
      type_candidate-pair.transportId: return !!getStatByType('candidate-pair', 'transportId');
      type_candidate-pair.type: return !!getStatByType('candidate-pair', 'type');
      type_certificate: return !!getStatByType('certificate');
      type_certificate.base64Certificate: return !!getStatByType('certificate', 'base64Certificate');
      type_certificate.fingerprint: return !!getStatByType('certificate', 'fingerprint');
      type_certificate.fingerprintAlgorithm: return !!getStatByType('certificate', 'fingerprintAlgorithm');
      type_certificate.id: return !!getStatByType('certificate', 'id');
      type_certificate.issuerCertificateId: return !!getStatByType('certificate', 'issuerCertificateId');
      type_certificate.timestamp: return !!getStatByType('certificate', 'timestamp');
      type_certificate.type: return !!getStatByType('certificate', 'type');
      type_codec: return !!getStatByType('codec');
      type_codec.channels: return !!getStatByType('codec', 'channels');
      type_codec.clockRate: return !!getStatByType('codec', 'clockRate');
      type_codec.id: return !!getStatByType('codec', 'id');
      type_codec.mimeType: return !!getStatByType('codec', 'mimeType');
      type_codec.payloadType: return !!getStatByType('codec', 'payloadType');
      type_codec.sdpFmtpLine: return !!getStatByType('codec', 'sdpFmtpLine');
      type_codec.timestamp: return !!getStatByType('codec', 'timestamp');
      type_codec.transportId: return !!getStatByType('codec', 'transportId');
      type_codec.type: return !!getStatByType('codec', 'type');
      type_data-channel: return !!getStatByType('data-channel');
      type_data-channel.bytesReceived: return !!getStatByType('data-channel', 'bytesReceived');
      type_data-channel.bytesSent: return !!getStatByType('data-channel', 'bytesSent');
      type_data-channel.dataChannelIdentifier: return !!getStatByType('data-channel', 'dataChannelIdentifier');
      type_data-channel.id: return !!getStatByType('data-channel', 'id');
      type_data-channel.label: return !!getStatByType('data-channel', 'label');
      type_data-channel.messagesReceived: return !!getStatByType('data-channel', 'messagesReceived');
      type_data-channel.messagesSent: return !!getStatByType('data-channel', 'messagesSent');
      type_data-channel.protocol: return !!getStatByType('data-channel', 'protocol');
      type_data-channel.state: return !!getStatByType('data-channel', 'state');
      type_data-channel.timestamp: return !!getStatByType('data-channel', 'timestamp');
      type_data-channel.type: return !!getStatByType('data-channel', 'type');
      type_inbound-rtp: return !!getStatByType('inbound-rtp');
      type_inbound-rtp.audioLevel: return !!getStatByType('inbound-rtp', 'audioLevel');
      type_inbound-rtp.bytesReceived: return !!getStatByType('inbound-rtp', 'bytesReceived');
      type_inbound-rtp.codecId: return !!getStatByType('inbound-rtp', 'codecId');
      type_inbound-rtp.concealedSamples: return !!getStatByType('inbound-rtp', 'concealedSamples');
      type_inbound-rtp.concealmentEvents: return !!getStatByType('inbound-rtp', 'concealmentEvents');
      type_inbound-rtp.decoderImplementation: return !!getStatByType('inbound-rtp', 'decoderImplementation');
      type_inbound-rtp.estimatedPlayoutTimestamp: return !!getStatByType('inbound-rtp', 'estimatedPlayoutTimestamp');
      type_inbound-rtp.fecPacketsDiscarded: return !!getStatByType('inbound-rtp', 'fecPacketsDiscarded');
      type_inbound-rtp.fecPacketsReceived: return !!getStatByType('inbound-rtp', 'fecPacketsReceived');
      type_inbound-rtp.firCount: return !!getStatByType('inbound-rtp', 'firCount');
      type_inbound-rtp.frameHeight: return !!getStatByType('inbound-rtp', 'frameHeight');
      type_inbound-rtp.frameWidth: return !!getStatByType('inbound-rtp', 'frameWidth');
      type_inbound-rtp.framesAssembledFromMultiplePackets: return !!getStatByType('inbound-rtp', 'framesAssembledFromMultiplePackets');
      type_inbound-rtp.framesDecoded: return !!getStatByType('inbound-rtp', 'framesDecoded');
      type_inbound-rtp.framesDropped: return !!getStatByType('inbound-rtp', 'framesDropped');
      type_inbound-rtp.framesPerSecond: return !!getStatByType('inbound-rtp', 'framesPerSecond');
      type_inbound-rtp.framesReceived: return !!getStatByType('inbound-rtp', 'framesReceived');
      type_inbound-rtp.framesRendered: return !!getStatByType('inbound-rtp', 'framesRendered');
      type_inbound-rtp.freezeCount: return !!getStatByType('inbound-rtp', 'freezeCount');
      type_inbound-rtp.headerBytesReceived: return !!getStatByType('inbound-rtp', 'headerBytesReceived');
      type_inbound-rtp.id: return !!getStatByType('inbound-rtp', 'id');
      type_inbound-rtp.insertedSamplesForDeceleration: return !!getStatByType('inbound-rtp', 'insertedSamplesForDeceleration');
      type_inbound-rtp.jitter: return !!getStatByType('inbound-rtp', 'jitter');
      type_inbound-rtp.jitterBufferDelay: return !!getStatByType('inbound-rtp', 'jitterBufferDelay');
      type_inbound-rtp.jitterBufferEmittedCount: return !!getStatByType('inbound-rtp', 'jitterBufferEmittedCount');
      type_inbound-rtp.jitterBufferMinimumDelay: return !!getStatByType('inbound-rtp', 'jitterBufferMinimumDelay');
      type_inbound-rtp.jitterBufferTargetDelay: return !!getStatByType('inbound-rtp', 'jitterBufferTargetDelay');
      type_inbound-rtp.keyFramesDecoded: return !!getStatByType('inbound-rtp', 'keyFramesDecoded');
      type_inbound-rtp.kind: return !!getStatByType('inbound-rtp', 'kind');
      type_inbound-rtp.lastPacketReceivedTimestamp: return !!getStatByType('inbound-rtp', 'lastPacketReceivedTimestamp');
      type_inbound-rtp.mid: return !!getStatByType('inbound-rtp', 'mid');
      type_inbound-rtp.nackCount: return !!getStatByType('inbound-rtp', 'nackCount');
      type_inbound-rtp.packetsDiscarded: return !!getStatByType('inbound-rtp', 'packetsDiscarded');
      type_inbound-rtp.packetsLost: return !!getStatByType('inbound-rtp', 'packetsLost');
      type_inbound-rtp.packetsReceived: return !!getStatByType('inbound-rtp', 'packetsReceived');
      type_inbound-rtp.pauseCount: return !!getStatByType('inbound-rtp', 'pauseCount');
      type_inbound-rtp.playoutId: return !!getStatByType('inbound-rtp', 'playoutId');
      type_inbound-rtp.pliCount: return !!getStatByType('inbound-rtp', 'pliCount');
      type_inbound-rtp.powerEfficientDecoder: return !!getStatByType('inbound-rtp', 'powerEfficientDecoder');
      type_inbound-rtp.qpSum: return !!getStatByType('inbound-rtp', 'qpSum');
      type_inbound-rtp.remoteId: return !!getStatByType('inbound-rtp', 'remoteId');
      type_inbound-rtp.removedSamplesForAcceleration: return !!getStatByType('inbound-rtp', 'removedSamplesForAcceleration');
      type_inbound-rtp.silentConcealedSamples: return !!getStatByType('inbound-rtp', 'silentConcealedSamples');
      type_inbound-rtp.ssrc: return !!getStatByType('inbound-rtp', 'ssrc');
      type_inbound-rtp.timestamp: return !!getStatByType('inbound-rtp', 'timestamp');
      type_inbound-rtp.totalAssemblyTime: return !!getStatByType('inbound-rtp', 'totalAssemblyTime');
      type_inbound-rtp.totalAudioEnergy: return !!getStatByType('inbound-rtp', 'totalAudioEnergy');
      type_inbound-rtp.totalDecodeTime: return !!getStatByType('inbound-rtp', 'totalDecodeTime');
      type_inbound-rtp.totalFreezesDuration: return !!getStatByType('inbound-rtp', 'totalFreezesDuration');
      type_inbound-rtp.totalInterFrameDelay: return !!getStatByType('inbound-rtp', 'totalInterFrameDelay');
      type_inbound-rtp.totalPausesDuration: return !!getStatByType('inbound-rtp', 'totalPausesDuration');
      type_inbound-rtp.totalProcessingDelay: return !!getStatByType('inbound-rtp', 'totalProcessingDelay');
      type_inbound-rtp.totalSamplesDuration: return !!getStatByType('inbound-rtp', 'totalSamplesDuration');
      type_inbound-rtp.totalSamplesReceived: return !!getStatByType('inbound-rtp', 'totalSamplesReceived');
      type_inbound-rtp.totalSquaredInterFrameDelay: return !!getStatByType('inbound-rtp', 'totalSquaredInterFrameDelay');
      type_inbound-rtp.trackIdentifier: return !!getStatByType('inbound-rtp', 'trackIdentifier');
      type_inbound-rtp.transportId: return !!getStatByType('inbound-rtp', 'transportId');
      type_inbound-rtp.type: return !!getStatByType('inbound-rtp', 'type');
      type_local-candidate: return !!getStatByType('local-candidate');
      type_local-candidate.address: return !!getStatByType('local-candidate', 'address');
      type_local-candidate.candidateType: return !!getStatByType('local-candidate', 'candidateType');
      type_local-candidate.foundation: return !!getStatByType('local-candidate', 'foundation');
      type_local-candidate.id: return !!getStatByType('local-candidate', 'id');
      type_local-candidate.port: return !!getStatByType('local-candidate', 'port');
      type_local-candidate.priority: return !!getStatByType('local-candidate', 'priority');
      type_local-candidate.protocol: return !!getStatByType('local-candidate', 'protocol');
      type_local-candidate.relatedAddress: |-
        return {result: null, message: 'Untestable property; requires a STUN/TURN server'};
        return !!getStatByType('local-candidate', 'relatedAddress');
      type_local-candidate.relatedPort: |-
        return {result: null, message: 'Untestable property; requires a STUN/TURN server'};
        return !!getStatByType('local-candidate', 'relatedPort');
      type_local-candidate.relayProtocol: |-
        return {result: null, message: 'Untestable property; requires a STUN/TURN server'};
        return !!getStatByType('local-candidate', 'relayProtocol');
      type_local-candidate.tcpType: return !!getStatByType('local-candidate', 'tcpType');
      type_local-candidate.timestamp: return !!getStatByType('local-candidate', 'timestamp');
      type_local-candidate.transportId: return !!getStatByType('local-candidate', 'transportId');
      type_local-candidate.type: return !!getStatByType('local-candidate', 'type');
      type_local-candidate.url: |-
        return {result: null, message: 'Untestable property; requires a STUN/TURN server'};
        return !!getStatByType('local-candidate', 'url');
      type_local-candidate.usernameFragment: return !!getStatByType('local-candidate', 'usernameFragment');
      type_media-playout: return !!getStatByType('media-playout');
      type_media-playout.id: return !!getStatByType('media-playout', 'id');
      type_media-playout.kind: return !!getStatByType('media-playout', 'kind');
      type_media-playout.synthesizedSamplesDuration: return !!getStatByType('media-playout', 'synthesizedSamplesDuration');
      type_media-playout.synthesizedSamplesEvents: return !!getStatByType('media-playout', 'synthesizedSamplesEvents');
      type_media-playout.timestamp: return !!getStatByType('media-playout', 'timestamp');
      type_media-playout.totalPlayoutDelay: return !!getStatByType('media-playout', 'totalPlayoutDelay');
      type_media-playout.totalSamplesCount: return !!getStatByType('media-playout', 'totalSamplesCount');
      type_media-playout.totalSamplesDuration: return !!getStatByType('media-playout', 'totalSamplesDuration');
      type_media-playout.type: return !!getStatByType('media-playout', 'type');
      type_media-source: return !!getStatByType('media-source');
      type_media-source.audioLevel: return !!getStatByType('media-source', 'audioLevel');
      type_media-source.droppedSamplesDuration: return !!getStatByType('media-source', 'droppedSamplesDuration');
      type_media-source.droppedSamplesEvents: return !!getStatByType('media-source', 'droppedSamplesEvents');
      type_media-source.echoReturnLoss: return !!getStatByType('media-source', 'echoReturnLoss');
      type_media-source.echoReturnLossEnhancement: return !!getStatByType('media-source', 'echoReturnLossEnhancement');
      type_media-source.frames: return !!getStatByType('media-source', 'frames');
      type_media-source.framesPerSecond: return !!getStatByType('media-source', 'framesPerSecond');
      type_media-source.height: return !!getStatByType('media-source', 'height');
      type_media-source.id: return !!getStatByType('media-source', 'id');
      type_media-source.kind: return !!getStatByType('media-source', 'kind');
      type_media-source.timestamp: return !!getStatByType('media-source', 'timestamp');
      type_media-source.totalAudioEnergy: return !!getStatByType('media-source', 'totalAudioEnergy');
      type_media-source.totalCaptureDelay: return !!getStatByType('media-source', 'totalCaptureDelay');
      type_media-source.totalSamplesCaptured: return !!getStatByType('media-source', 'totalSamplesCaptured');
      type_media-source.totalSamplesDuration: return !!getStatByType('media-source', 'totalSamplesDuration');
      type_media-source.trackIdentifier: return !!getStatByType('media-source', 'trackIdentifier');
      type_media-source.type: return !!getStatByType('media-source', 'type');
      type_media-source.width: return !!getStatByType('media-source', 'width');
      type_outbound-rtp: return !!getStatByType('outbound-rtp');
      type_outbound-rtp.active: return !!getStatByType('outbound-rtp', 'active');
      type_outbound-rtp.bytesSent: return !!getStatByType('outbound-rtp', 'bytesSent');
      type_outbound-rtp.codecId: return !!getStatByType('outbound-rtp', 'codecId');
      type_outbound-rtp.encoderImplementation: return !!getStatByType('outbound-rtp', 'encoderImplementation');
      type_outbound-rtp.firCount: return !!getStatByType('outbound-rtp', 'firCount');
      type_outbound-rtp.frameHeight: return !!getStatByType('outbound-rtp', 'frameHeight');
      type_outbound-rtp.frameWidth: return !!getStatByType('outbound-rtp', 'frameWidth');
      type_outbound-rtp.framesEncoded: return !!getStatByType('outbound-rtp', 'framesEncoded');
      type_outbound-rtp.framesPerSecond: return !!getStatByType('outbound-rtp', 'framesPerSecond');
      type_outbound-rtp.framesSent: return !!getStatByType('outbound-rtp', 'framesSent');
      type_outbound-rtp.headerBytesSent: return !!getStatByType('outbound-rtp', 'headerBytesSent');
      type_outbound-rtp.hugeFramesSent: return !!getStatByType('outbound-rtp', 'hugeFramesSent');
      type_outbound-rtp.id: return !!getStatByType('outbound-rtp', 'id');
      type_outbound-rtp.keyFramesEncoded: return !!getStatByType('outbound-rtp', 'keyFramesEncoded');
      type_outbound-rtp.kind: return !!getStatByType('outbound-rtp', 'kind');
      type_outbound-rtp.mediaSourceId: return !!getStatByType('outbound-rtp', 'mediaSourceId');
      type_outbound-rtp.mid: return !!getStatByType('outbound-rtp', 'mid');
      type_outbound-rtp.nackCount: return !!getStatByType('outbound-rtp', 'nackCount');
      type_outbound-rtp.packetsSent: return !!getStatByType('outbound-rtp', 'packetsSent');
      type_outbound-rtp.pliCount: return !!getStatByType('outbound-rtp', 'pliCount');
      type_outbound-rtp.powerEfficientEncoder: return !!getStatByType('outbound-rtp', 'powerEfficientEncoder');
      type_outbound-rtp.qpSum: return !!getStatByType('outbound-rtp', 'qpSum');
      type_outbound-rtp.qualityLimitationDurations: return !!getStatByType('outbound-rtp', 'qualityLimitationDurations');
      type_outbound-rtp.qualityLimitationReason: return !!getStatByType('outbound-rtp', 'qualityLimitationReason');
      type_outbound-rtp.qualityLimitationResolutionChanges: return !!getStatByType('outbound-rtp', 'qualityLimitationResolutionChanges');
      type_outbound-rtp.remoteId: return !!getStatByType('outbound-rtp', 'remoteId');
      type_outbound-rtp.retransmittedBytesSent: return !!getStatByType('outbound-rtp', 'retransmittedBytesSent');
      type_outbound-rtp.retransmittedPacketsSent: return !!getStatByType('outbound-rtp', 'retransmittedPacketsSent');
      type_outbound-rtp.rid: |-
        return {result: null, message: 'Untestable property; requires simulcast'};
        return !!getStatByType('outbound-rtp', 'rid');
      type_outbound-rtp.scalabilityMode: return !!getStatByType('outbound-rtp', 'scalabilityMode');
      type_outbound-rtp.ssrc: return !!getStatByType('outbound-rtp', 'ssrc');
      type_outbound-rtp.targetBitrate: return !!getStatByType('outbound-rtp', 'targetBitrate');
      type_outbound-rtp.timestamp: return !!getStatByType('outbound-rtp', 'timestamp');
      type_outbound-rtp.totalEncodeTime: return !!getStatByType('outbound-rtp', 'totalEncodeTime');
      type_outbound-rtp.totalEncodedBytesTarget: return !!getStatByType('outbound-rtp', 'totalEncodedBytesTarget');
      type_outbound-rtp.totalPacketSendDelay: return !!getStatByType('outbound-rtp', 'totalPacketSendDelay');
      type_outbound-rtp.transportId: return !!getStatByType('outbound-rtp', 'transportId');
      type_outbound-rtp.type: return !!getStatByType('outbound-rtp', 'type');
      type_peer-connection: return !!getStatByType('peer-connection');
      type_peer-connection.dataChannelsClosed: return !!getStatByType('peer-connection', 'dataChannelsClosed');
      type_peer-connection.dataChannelsOpened: return !!getStatByType('peer-connection', 'dataChannelsOpened');
      type_peer-connection.id: return !!getStatByType('peer-connection', 'id');
      type_peer-connection.timestamp: return !!getStatByType('peer-connection', 'timestamp');
      type_peer-connection.type: return !!getStatByType('peer-connection', 'type');
      type_remote-candidate: return !!getStatByType('remote-candidate');
      type_remote-candidate.address: return !!getStatByType('remote-candidate', 'address');
      type_remote-candidate.candidateType: return !!getStatByType('remote-candidate', 'candidateType');
      type_remote-candidate.foundation: return !!getStatByType('remote-candidate', 'foundation');
      type_remote-candidate.id: return !!getStatByType('remote-candidate', 'id');
      type_remote-candidate.port: return !!getStatByType('remote-candidate', 'port');
      type_remote-candidate.priority: return !!getStatByType('remote-candidate', 'priority');
      type_remote-candidate.protocol: return !!getStatByType('remote-candidate', 'protocol');
      type_remote-candidate.relatedAddress: |-
        return {result: null, message: 'Untestable property; requires a STUN/TURN server'};
        return !!getStatByType('remote-candidate', 'relatedAddress');
      type_remote-candidate.relatedPort: |-
        return {result: null, message: 'Untestable property; requires a STUN/TURN server'};
        return !!getStatByType('remote-candidate', 'relatedPort');
      type_remote-candidate.relayProtocol: |-
        return {result: null, message: 'Untestable property; requires a STUN/TURN server'};
        return !!getStatByType('remote-candidate', 'relayProtocol');
      type_remote-candidate.tcpType: |-
        return {result: null, message: 'Untestable property; requires a STUN/TURN server'};
        return !!getStatByType('remote-candidate', 'tcpType');
      type_remote-candidate.timestamp: return !!getStatByType('remote-candidate', 'timestamp');
      type_remote-candidate.transportId: return !!getStatByType('remote-candidate', 'transportId');
      type_remote-candidate.type: return !!getStatByType('remote-candidate', 'type');
      type_remote-candidate.url: |-
        return {result: null, message: 'Untestable property; requires a STUN/TURN server'};
        return !!getStatByType('remote-candidate', 'url');
      type_remote-candidate.usernameFragment: return !!getStatByType('remote-candidate', 'usernameFragment');
      type_remote-inbound-rtp: return !!getStatByType('remote-inbound-rtp');
      type_remote-inbound-rtp.codecId: return !!getStatByType('remote-inbound-rtp', 'codecId');
      type_remote-inbound-rtp.fractionLost: return !!getStatByType('remote-inbound-rtp', 'fractionLost');
      type_remote-inbound-rtp.id: return !!getStatByType('remote-inbound-rtp', 'id');
      type_remote-inbound-rtp.jitter: return !!getStatByType('remote-inbound-rtp', 'jitter');
      type_remote-inbound-rtp.kind: return !!getStatByType('remote-inbound-rtp', 'kind');
      type_remote-inbound-rtp.localId: return !!getStatByType('remote-inbound-rtp', 'localId');
      type_remote-inbound-rtp.packetsLost: return !!getStatByType('remote-inbound-rtp', 'packetsLost');
      type_remote-inbound-rtp.packetsReceived: return !!getStatByType('remote-inbound-rtp', 'packetsReceived');
      type_remote-inbound-rtp.roundTripTime: return !!getStatByType('remote-inbound-rtp', 'roundTripTime');
      type_remote-inbound-rtp.roundTripTimeMeasurements: return !!getStatByType('remote-inbound-rtp', 'roundTripTimeMeasurements');
      type_remote-inbound-rtp.ssrc: return !!getStatByType('remote-inbound-rtp', 'ssrc');
      type_remote-inbound-rtp.timestamp: return !!getStatByType('remote-inbound-rtp', 'timestamp');
      type_remote-inbound-rtp.totalRoundTripTime: return !!getStatByType('remote-inbound-rtp', 'totalRoundTripTime');
      type_remote-inbound-rtp.transportId: return !!getStatByType('remote-inbound-rtp', 'transportId');
      type_remote-inbound-rtp.type: return !!getStatByType('remote-inbound-rtp', 'type');
      type_remote-outbound-rtp: return !!getStatByType('remote-outbound-rtp');
      type_remote-outbound-rtp.bytesSent: return !!getStatByType('remote-outbound-rtp', 'bytesSent');
      type_remote-outbound-rtp.codecId: return !!getStatByType('remote-outbound-rtp', 'codecId');
      type_remote-outbound-rtp.id: return !!getStatByType('remote-outbound-rtp', 'id');
      type_remote-outbound-rtp.kind: return !!getStatByType('remote-outbound-rtp', 'kind');
      type_remote-outbound-rtp.localId: return !!getStatByType('remote-outbound-rtp', 'localId');
      type_remote-outbound-rtp.packetsSent: return !!getStatByType('remote-outbound-rtp', 'packetsSent');
      type_remote-outbound-rtp.remoteTimestamp: return !!getStatByType('remote-outbound-rtp', 'remoteTimestamp');
      type_remote-outbound-rtp.reportsSent: return !!getStatByType('remote-outbound-rtp', 'reportsSent');
      type_remote-outbound-rtp.roundTripTime: return !!getStatByType('remote-outbound-rtp', 'roundTripTime');
      type_remote-outbound-rtp.roundTripTimeMeasurements: return !!getStatByType('remote-outbound-rtp', 'roundTripTimeMeasurements');
      type_remote-outbound-rtp.ssrc: return !!getStatByType('remote-outbound-rtp', 'ssrc');
      type_remote-outbound-rtp.timestamp: return !!getStatByType('remote-outbound-rtp', 'timestamp');
      type_remote-outbound-rtp.totalRoundTripTime: return !!getStatByType('remote-outbound-rtp', 'totalRoundTripTime');
      type_remote-outbound-rtp.transportId: return !!getStatByType('remote-outbound-rtp', 'transportId');
      type_remote-outbound-rtp.type: return !!getStatByType('remote-outbound-rtp', 'type');
      type_transport: return !!getStatByType('transport');
      type_transport.bytesReceived: return !!getStatByType('transport', 'bytesReceived');
      type_transport.bytesSent: return !!getStatByType('transport', 'bytesSent');
      type_transport.dtlsCipher: return !!getStatByType('transport', 'dtlsCipher');
      type_transport.dtlsRole: return !!getStatByType('transport', 'dtlsRole');
      type_transport.dtlsState: return !!getStatByType('transport', 'dtlsState');
      type_transport.iceLocalUsernameFragment: return !!getStatByType('transport', 'iceLocalUsernameFragment');
      type_transport.iceRole: return !!getStatByType('transport', 'iceRole');
      type_transport.iceState: return !!getStatByType('transport', 'iceState');
      type_transport.id: return !!getStatByType('transport', 'id');
      type_transport.localCertificateId: return !!getStatByType('transport', 'localCertificateId');
      type_transport.packetsReceived: return !!getStatByType('transport', 'packetsReceived');
      type_transport.packetsSent: return !!getStatByType('transport', 'packetsSent');
      type_transport.remoteCertificateId: return !!getStatByType('transport', 'remoteCertificateId');
      type_transport.selectedCandidatePairChanges: return !!getStatByType('transport', 'selectedCandidatePairChanges');
      type_transport.selectedCandidatePairId: return !!getStatByType('transport', 'selectedCandidatePairId');
      type_transport.srtpCipher: return !!getStatByType('transport', 'srtpCipher');
      type_transport.timestamp: return !!getStatByType('transport', 'timestamp');
      type_transport.tlsVersion: return !!getStatByType('transport', 'tlsVersion');
      type_transport.type: return !!getStatByType('transport', 'type');
  Screen:
    __base: var instance = window.screen;
  ScriptProcessorNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createScriptProcessor' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createScriptProcessor is not defined'};
      }
      var instance = reusableInstances.audioContext.createScriptProcessor();
  SecurityPolicyViolationEvent:
    __base: |-
      bcd.skipIf('Constructing this event causes the page to reload', 'edge', '15');

      if (!('SecurityPolicyViolationEvent' in self)) {
        return {result: false, message: 'SecurityPolicyViolationEvent is not defined'};
      }
      var instance = new SecurityPolicyViolationEvent('securitypolicyviolation');
  Selection:
    __base: var instance = window.getSelection();
    collapse:
      __additional:
        node_parameter_nullable: |-
          try {
            if (!(instance && instance.collapse)) {
              return {result: false, message: 'instance.collapse is not defined'};
            }
            instance.collapse(null);
            return true;
          } catch(e) {
            if (e instanceof TypeError || stringIncludes(e.message, ['WRONG_ARGUMENTS_ERR', 'Not enough arguments'])) {
              return {result: false, message: e.message};
            }
            return e;
          }
        offset_parameter_optional: |-
          try {
            if (!(instance && instance.collapse)) {
              return {result: false, message: 'instance.collapse is not defined'};
            }
            instance.collapse(document.createElement("p"));
            return true;
          } catch(e) {
            if (e instanceof TypeError || stringIncludes(e.message, ['WRONG_ARGUMENTS_ERR', 'Not enough arguments'])) {
              return {result: false, message: e.message};
            }
            return e;
          }
    containsNode:
      __additional:
        partialContainment_parameter_optional: |-
          try {
            if (!(instance && instance.containsNode)) {
              return {result: false, message: 'instance.containsNode is not defined'};
            }
            instance.containsNode(document.createElement("p"));
            return true;
          } catch(e) {
            if (e instanceof TypeError || stringIncludes(e.message, ['WRONG_ARGUMENTS_ERR', 'Not enough arguments'])) {
              return {result: false, message: e.message};
            }
            return e;
          }
    extend:
      __additional:
        offset_parameter_optional: |-
          try {
            if (!(instance && instance.extend)) {
              return {result: false, message: 'instance.extend is not defined'};
            }
            instance.extend(document.createElement("p"));
            return true;
          } catch(e) {
            if (e instanceof TypeError || stringIncludes(e.message, ['WRONG_ARGUMENTS_ERR', 'Not enough arguments'])) {
              return {result: false, message: e.message};
            }
            return e;
          }
  ServiceWorkerContainer:
    __base: var instance = navigator.serviceWorker;
  ShadowRoot:
    __base: |-
      var el = document.createElement('div');
      if (!el.attachShadow) {
        return {result: false, message: 'Element.attachShadow is not defined'};
      };
      el.attachShadow({mode: 'open'});
      var instance = el.shadowRoot;
  SpeechRecognition:
    __resources:
      - speechRecognition
    __base: var instance = reusableInstances.speechRecognition;
    __test: return 'SpeechRecognition' in self;
  SpeechGrammar:
    __base: |-
      <%api.SpeechGrammarList:sglist%>
      var instance = sglist[0];
  SpeechGrammarList:
    __resources:
      - speechRecognition
    __base: |-
      if (!('SpeechGrammarList' in self || 'webkitSpeechGrammarList' in self)) {
        return {result: false, message: 'SpeechGrammarList is not defined'};
      }
      var grammar = "#JSGF V1.0; grammar colors; public <color> = aqua | azure | beige | bisque | black | blue | brown | chocolate | coral | crimson | cyan | fuchsia | ghostwhite | gold | goldenrod | gray | green | indigo | ivory | khaki | lavender | lime | linen | magenta | maroon | moccasin | navy | olive | orange | orchid | peru | pink | plum | purple | red | salmon | sienna | silver | snow | tan | teal | thistle | tomato | turquoise | violet | white | yellow ;";
      var instance = new (SpeechGrammarList || webkitSpeechGrammarList)();
      speechRecognitionList.addFromString(grammar, 1);
  SpeechRecognitionAlternative:
    __base: |-
      // XXX no idea how to synthetically generate this interface
      return {Alternative: null, message: 'Testing for SpeechRecognitionResult is not yet implemented'};
  SpeechRecognitionErrorEvent:
    __base: |-
      var instance;
      try {
        instance = new SpeechRecognitionErrorEvent('error', {error: 'aborted'});
      } catch(e) {
        return {result: false, message: 'Cannot create event'};
      }
  SpeechRecognitionEvent:
    __base: |-
      // XXX need to create a SpeechRecognitionResultList and pass it to the results argument
      return {result: null, message: 'Testing for SpeechRecognitionEvent is not yet implemented'};

      var instance;
      try {
        instance = new SpeechRecognitionEvent('result', {results: null});
      } catch(e) {
        return {result: false, message: 'Cannot create event'};
      }
  SpeechRecognitionResult:
    __base: |-
      // XXX no idea how to synthetically generate this interface
      return {result: null, message: 'Testing for SpeechRecognitionResult is not yet implemented'};
  SpeechRecognitionResultList:
    __base: |-
      // XXX no idea how to synthetically generate this interface
      return {result: null, message: 'Testing for SpeechRecognitionResultList is not yet implemented'};
  SpeechSynthesis:
    __base: var instance = window.speechSynthesis;
  SpeechSynthesisErrorEvent:
    __base: |-
      <%api.SpeechSynthesisUtterance:utterance%>
      var instance;
      try {
        instance = new SpeechSynthesisErrorEvent('error', { utterance: utterance, error: 'canceled' });
      } catch(e) {
        return {result: false, message: 'Cannot create event'};
      }
  SpeechSynthesisEvent:
    __base: |-
      <%api.SpeechSynthesisUtterance:utterance%>
      var instance;
      try {
        instance = new SpeechSynthesisEvent('start', { utterance: utterance });
      } catch(e) {
        return {result: false, message: 'Cannot create event'};
      }
  SpeechSynthesisUtterance:
    __base: var instance = new SpeechSynthesisUtterance('Hello world!');
  SpeechSynthesisVoice:
    __base: |-
      <%api.SpeechSynthesis:synth%>
      // Firefox has a bug where speech synthesis voices aren't loaded on the first call
      synth.getVoices();
      // Browsers have a bug where speech synthesis voices aren't loaded immediately
      setTimeout(function() {
        callback(synth.getVoices()[0]);
      }, 2000);
  StereoPannerNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createStereoPanner' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createStereoPanner is not defined'};
      }
      var instance = reusableInstances.audioContext.createStereoPanner();
  StorageEvent:
    __base: |-
      var instance;
      try {
        instance = new StorageEvent('storage');
      } catch(e) {
        try {
          instance = document.createEvent('StorageEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  StorageManager:
    __additional:
      estimate.usageDetails: |-
        if (!('storage' in navigator)) {
          return {result: false, message: "navigator.storage is not defined"};
        }
        if (!('estimate' in navigator.storage)) {
          return {result: false, message: "navigator.storage.estimate is not defined"};
        }
        return navigator.storage.estimate().then(function (estimate) {
          return !!estimate.usageDetails;
        });
  StyleMedia:
    __base: var instance = window.styleMedia;
  StyleSheet:
    __resources:
      - createStyleSheet
    __base: <%api.CSSStyleSheet:instance%>
  StyleSheetList:
    __base: var instance = document.styleSheets;
  SubtleCrypto:
    __base: |-
      if (!('crypto' in self)) {
        return {result: false, message: 'crypto is not defined'};
      };
      var instance = crypto.subtle || crypto.webkitSubtle;
  SVGAElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'a');
    __test: return bcd.testObjectName(instance, 'SVGAElement');
  SVGAngle:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGAngle();
  SVGAnimatedAngle:
    __base: |-
      <%api.SVGMarkerElement:el%>
      var instance = el.orientAngle;
  SVGAnimatedBoolean:
    __base: |-
      <%api.SVGFEConvolveMatrixElement:el%>
      var instance = el.preserveAlpha;
  SVGAnimatedEnumeration:
    __base: |-
      <%api.SVGMarkerElement:el%>
      var instance = el.orientType;
  SVGAnimatedInteger:
    __base: |-
      <%api.SVGFEConvolveMatrixElement:el%>
      var instance = el.orderX;
  SVGAnimatedLength:
    __base: |-
      <%api.SVGMarkerElement:el%>
      var instance = el.refX;
  SVGAnimatedLengthList:
    __base: |-
      <%api.SVGTextPositioningElement:el%>
      var instance = el.x;
  SVGAnimatedNumber:
    __base: |-
      <%api.SVGStopElement:el%>
      var instance = el.offset;
  SVGAnimatedNumberList:
    __base: |-
      <%api.SVGFEConvolveMatrixElement:el%>
      var instance = el.kernelMatrix;
  SVGAnimatedPreserveAspectRatio:
    __base: |-
      <%api.SVGFEImageElement:el%>
      var instance = el.preserveAspectRatio;
  SVGAnimatedRect:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.viewBox;
  SVGAnimatedString:
    __base: |-
      <%api.SVGElement:el%>
      var instance = el.className;
  SVGAnimatedTransformList:
    __base: |-
      <%api.SVGGraphicsElement:el%>
      var instance = el.transform;
  SVGAnimateColorElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'animateColor');
    __test: return bcd.testObjectName(instance, 'SVGAnimateColorElement');
  SVGAnimateElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
    __test: return bcd.testObjectName(instance, 'SVGAnimateElement');
  SVGAnimateMotionElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'animateMotion');
    __test: return bcd.testObjectName(instance, 'SVGAnimateMotionElement');
  SVGAnimateTransformElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'animateTransform');
    __test: return bcd.testObjectName(instance, 'SVGAnimateTransformElement');
  SVGAnimationElement:
    __base: <%api.SVGAnimateElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGAnimateElement');
  SVGCircleElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    __test: return bcd.testObjectName(instance, 'SVGCircleElement');
  SVGClipPathElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
    __test: return bcd.testObjectName(instance, 'SVGClipPathElement');
  SVGColorProfileElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'color-profile');
    __test: return bcd.testObjectName(instance, 'SVGColorProfileElement');
  SVGComponentTransferFunctionElement:
    __base: <%api.SVGFEFuncAElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGFEFuncAElement');
  SVGCursorElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'cursor');
    __test: return bcd.testObjectName(instance, 'SVGCursorElement');
  SVGDefsElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    __test: return bcd.testObjectName(instance, 'SVGDefsElement');
  SVGDescElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'desc');
    __test: return bcd.testObjectName(instance, 'SVGDescElement');
  SVGDiscardElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'discard');
    __test: return bcd.testObjectName(instance, 'SVGDiscardElement');
  SVGElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'title');
    focus:
      __additional:
        options_preventScroll_parameter: return bcd.testOptionParam(instance, 'focus', 'preventScroll', true);
  SVGEllipseElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
    __test: return bcd.testObjectName(instance, 'SVGEllipseElement');
  SVGFEBlendElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feBlend');
    __test: return bcd.testObjectName(instance, 'SVGFEBlendElement');
  SVGFEColorMatrixElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feColorMatrix');
    __test: return bcd.testObjectName(instance, 'SVGFEColorMatrixElement');
  SVGFEComponentTransferElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feComponentTransfer');
    __test: return bcd.testObjectName(instance, 'SVGFEComponentTransferElement');
  SVGFECompositeElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feComposite');
    __test: return bcd.testObjectName(instance, 'SVGFECompositeElement');
  SVGFEConvolveMatrixElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feConvolveMatrix');
    __test: return bcd.testObjectName(instance, 'SVGFEConvolveMatrixElement');
  SVGFEDiffuseLightingElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feDiffuseLighting');
    __test: return bcd.testObjectName(instance, 'SVGFEDiffuseLightingElement');
  SVGFEDisplacementMapElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feDisplacementMap');
    __test: return bcd.testObjectName(instance, 'SVGFEDisplacementMapElement');
  SVGFEDistantLightElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feDistantLight');
    __test: return bcd.testObjectName(instance, 'SVGFEDistantLightElement');
  SVGFEDropShadowElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feDropShadow');
    __test: return bcd.testObjectName(instance, 'SVGFEDropShadowElement');
  SVGFEFloodElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feFlood');
    __test: return bcd.testObjectName(instance, 'SVGFEFloodElement');
  SVGFEFuncAElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncA');
    __test: return bcd.testObjectName(instance, 'SVGFEFuncAElement');
  SVGFEFuncBElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncB');
    __test: return bcd.testObjectName(instance, 'SVGFEFuncBElement');
  SVGFEFuncGElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncG');
    __test: return bcd.testObjectName(instance, 'SVGFEFuncGElement');
  SVGFEFuncRElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncR');
    __test: return bcd.testObjectName(instance, 'SVGFEFuncRElement');
  SVGFEGaussianBlurElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
    __test: return bcd.testObjectName(instance, 'SVGFEGaussianBlurElement');
  SVGFEImageElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feImage');
    __test: return bcd.testObjectName(instance, 'SVGFEImageElement');
  SVGFEMergeElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
    __test: return bcd.testObjectName(instance, 'SVGFEMergeElement');
  SVGFEMergeNodeElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
    __test: return bcd.testObjectName(instance, 'SVGFEMergeNodeElement');
  SVGFEMorphologyElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feMorphology');
    __test: return bcd.testObjectName(instance, 'SVGFEMorphologyElement');
  SVGFEOffsetElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feOffset');
    __test: return bcd.testObjectName(instance, 'SVGFEOffsetElement');
  SVGFEPointLightElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'fePointLight');
    __test: return bcd.testObjectName(instance, 'SVGFEPointLightElement');
  SVGFESpecularLightingElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feSpecularLighting');
    __test: return bcd.testObjectName(instance, 'SVGFESpecularLightingElement');
  SVGFESpotLightElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feSpotLight');
    __test: return bcd.testObjectName(instance, 'SVGFESpotLightElement');
  SVGFETileElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feTile');
    __test: return bcd.testObjectName(instance, 'SVGFETileElement');
  SVGFETurbulenceElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'feTurbulence');
    __test: return bcd.testObjectName(instance, 'SVGFETurbulenceElement');
  SVGFilterElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
    __test: return bcd.testObjectName(instance, 'SVGFilterElement');
  SVGFontElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font');
    __test: return bcd.testObjectName(instance, 'SVGFontElement');
  SVGFontFaceElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font-face');
    __test: return bcd.testObjectName(instance, 'SVGFontFaceElement');
  SVGFontFaceFormatElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font-face-format');
    __test: return bcd.testObjectName(instance, 'SVGFontFaceFormatElement');
  SVGFontFaceNameElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font-face-name');
    __test: return bcd.testObjectName(instance, 'SVGFontFaceNameElement');
  SVGFontFaceSrcElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font-face-src');
    __test: return bcd.testObjectName(instance, 'SVGFontFaceSrcElement');
  SVGFontFaceUriElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'font-face-uri');
    __test: return bcd.testObjectName(instance, 'SVGFontFaceUriElement');
  SVGForeignObjectElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
    __test: return bcd.testObjectName(instance, 'SVGForeignObjectElement');
  SVGGElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    __test: return bcd.testObjectName(instance, 'SVGGElement');
  SVGGeometryElement:
    __base: <%api.SVGPathElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGPathElement');
    isPointInFill:
      __additional:
        point_parameter_DOMPoint: |-
          try {
            instance.isPointInFill(new DOMPoint(20, 20));
            return true;
          } catch (e) {
            return {result: false, message: e.message};
          }
    isPointInStroke:
      __additional:
        point_parameter_DOMPoint: |-
          try {
            instance.isPointInStroke(new DOMPoint(20, 20));
            return true;
          } catch (e) {
            return {result: false, message: e.message};
          }
  SVGGlyphElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'glyph');
    __test: return bcd.testObjectName(instance, 'SVGGlyphElement');
  SVGGlyphRefElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'glyphRef');
    __test: return bcd.testObjectName(instance, 'SVGGlyphRefElement');
  SVGGradientElement:
    __base: <%api.SVGLinearGradientElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGLinearGradientElement');
  SVGGraphicsElement:
    __base: <%api.SVGImageElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGImageElement');
  SVGHKernElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'hkern');
    __test: return bcd.testObjectName(instance, 'SVGHKernElement');
  SVGImageElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'image');
    __test: return bcd.testObjectName(instance, 'SVGImageElement');
  SVGLength:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGLength();
  SVGLengthList:
    __base: |-
      <%api.SVGAnimatedLengthList:list%>
      var instance = list.baseVal;
  SVGLinearGradientElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
    __test: return bcd.testObjectName(instance, 'SVGLinearGradientElement');
  SVGLineElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    __test: return bcd.testObjectName(instance, 'SVGLineElement');
  SVGMarkerElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    __test: return bcd.testObjectName(instance, 'SVGMarkerElement');
  SVGMaskElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
    __test: return bcd.testObjectName(instance, 'SVGMaskElement');
  SVGMeshElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'mesh');
    __test: return bcd.testObjectName(instance, 'SVGMeshElement');
  SVGMetadataElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');
    __test: return bcd.testObjectName(instance, 'SVGMetadataElement');
  SVGMissingGlyphElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'missing-glyph');
    __test: return bcd.testObjectName(instance, 'SVGMissingGlyphElement');
  SVGMPathElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'mpath');
    __test: return bcd.testObjectName(instance, 'SVGMPathElement');
  SVGNumber:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGNumber();
  SVGNumberList:
    __base: |-
      <%api.SVGAnimatedNumberList:list%>
      var instance = list.baseVal;
  SVGPathElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    __test: return bcd.testObjectName(instance, 'SVGPathElement');
  SVGPatternElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
    __test: return bcd.testObjectName(instance, 'SVGPatternElement');
  SVGPoint:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGPoint();
  SVGPointList:
    __base: |-
      <%api.SVGPolygonElement:el%>
      var instance = el.points;
  SVGPolygonElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    __test: return bcd.testObjectName(instance, 'SVGPolygonElement');
  SVGPolylineElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    __test: return bcd.testObjectName(instance, 'SVGPolylineElement');
  SVGPreserveAspectRatio:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.preserveAspectRatio.baseVal;
  SVGRadialGradientElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
    __test: return bcd.testObjectName(instance, 'SVGRadialGradientElement');
  SVGRect:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGRect();
  SVGRectElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    __test: return bcd.testObjectName(instance, 'SVGRectElement');
  SVGScriptElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'script');
    __test: return bcd.testObjectName(instance, 'SVGScriptElement');
  SVGSetElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'set');
    __test: return bcd.testObjectName(instance, 'SVGSetElement');
  SVGSolidcolorElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'solidcolor');
    __test: return bcd.testObjectName(instance, 'SVGSolidcolorElement');
  SVGStopElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    __test: return bcd.testObjectName(instance, 'SVGStopElement');
  SVGStringList:
    __base: |-
      <%api.SVGGraphicsElement:el%>
      var instance = el.systemLanguage;
  SVGStyleElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'style');
    __test: return bcd.testObjectName(instance, 'SVGStyleElement');
  SVGSVGElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    __test: return bcd.testObjectName(instance, 'SVGSVGElement');
  SVGSwitchElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'switch');
    __test: return bcd.testObjectName(instance, 'SVGSwitchElement');
  SVGSymbolElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'symbol');
    __test: return bcd.testObjectName(instance, 'SVGSymbolElement');
  SVGTextElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    __test: return bcd.testObjectName(instance, 'SVGTextElement');
  SVGTextContentElement:
    __base: <%api.SVGTextElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGTextElement');
  SVGTextPathElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'textPath');
    __test: return bcd.testObjectName(instance, 'SVGTextPathElement');
  SVGTextPositioningElement:
    __base: <%api.SVGTextElement:instance%>
    __test: return bcd.testObjectName(instance, 'SVGTextElement');
  SVGTitleElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'title');
    __test: return bcd.testObjectName(instance, 'SVGTitleElement');
  SVGTransform:
    __base: |-
      <%api.SVGSVGElement:el%>
      var instance = el.createSVGTransform();
  SVGTransformList:
    __base: |-
      <%api.SVGAnimatedTransformList:list%>
      var instance = list.baseVal;
  SVGTRefElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'tref');
    __test: return bcd.testObjectName(instance, 'SVGTRefElement');
  SVGTSpanElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
    __test: return bcd.testObjectName(instance, 'SVGTSpanElement');
  SVGUnknownElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'unknown');
    __test: return bcd.testObjectName(instance, 'SVGUnknownElement');
  SVGUseElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'use');
    __test: return bcd.testObjectName(instance, 'SVGUseElement');
  SVGViewElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'view');
    __test: return bcd.testObjectName(instance, 'SVGViewElement');
  SVGVKernElement:
    __base: var instance = document.createElementNS('http://www.w3.org/2000/svg', 'vkern');
    __test: return bcd.testObjectName(instance, 'SVGVKernElement');
  Text:
    __base: |-
      var el = document.createElement('b');
      el.innerHTML = 'text';
      var instance
      = el.childNodes[0];
  TextDecoder:
    __base: |-
      if (!('TextDecoder' in self)) {
        return {result: false, message: 'TextDecoder is not defined'};
      };
      var instance = new TextDecoder();
  TextEncoder:
    __base: |-
      if (!('TextEncoder' in self)) {
        return {result: false, message: 'TextEncoder is not defined'};
      };
      var instance = new TextEncoder();
  TextMetrics:
    __base: |-
      <%api.CanvasRenderingContext2D:ctx%>
      var instance = ctx.measureText('mdn-bcd-collector');
  TextTrack:
    __resources:
      - video-blank
    __base: |-
      <%api.TextTrackList:texttracks%>
      var instance = texttracks[0];
  TextTrackCue:
    __resources:
      - video-blank
    __base: |-
      <%api.TextTrackCueList:cues%>
      var instance = cues[0];
  TextTrackCueList:
    __resources:
      - video-blank
    __base: |-
      <%api.TextTrack:texttrack%>
      var instance = texttrack.cues;
  TextTrackList:
    __resources:
      - video-blank
    __base: |-
      var el = document.getElementById('resource-video-blank');
      var instance = el.textTracks;
  TimeRanges:
    __resources:
      - video-blank
    __base: |-
      var el = document.getElementById('resource-video-blank');
      var instance = el.buffered;
  TouchEvent:
    __base: |-
      if (!('TouchEvent' in self)) {
        return {result: false, message: 'TouchEvent is not defined'};
      }
      var instance = new TouchEvent('touchstart');
  TrackEvent:
    __base: |-
      var instance;
      try {
        instance = new TrackEvent('addtrack');
      } catch(e) {
        try {
          instance = document.createEvent('TrackEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  TransformStreamDefaultController:
    __base: |-
      if (!('TransformStream' in self)) {
        return {result: false, message: 'TransformStream is not defined'};
      }
      new TransformStream({
        start(controller) {
          callback(controller);
        },
      });
  TransitionEvent:
    __base: |-
      var instance;
        try {instance = new TransitionEvent('transitionend');
      } catch(e) {
        try {
          instance = document.createEvent('TransitionEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  TreeWalker:
    __base: var instance = document.createTreeWalker(document);
  UIEvent:
    __base: |-
      var instance;
      try {
        instance = new UIEvent('');
      } catch(e) {
        try {
          instance = document.createEvent('UIEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  URL:
    __base: |-
      var instance;
      try {
        instance = new URL(location.href)
      } catch(e) {
        instance = new webkitURL(location.href)
      };
    __test: return 'URL' in self;
  URLPattern:
    __base: |-
      if (!('URLPattern' in self)) {
        return {result: false, message: 'URLPattern is not defined'};
      }
      var instance = new URLPattern('https://mdn-bcd-collector.gooborg.com/tests/*');
    URLPattern:
      __additional:
        ignoreCase_option: |-
          function constructor(options) {
            new URLPattern('https://mdn-bcd-collector.gooborg.com/tests/*', options);
          }
          return bcd.testOptionParam(constructor, null, 'ignoreCase', true);
  URLSearchParams:
    __base: |-
      if (!('URLSearchParams' in self)) {
        return {result: false, message: 'URLSearchParams is not defined'};
      }
      var instance = new URLSearchParams("q=HelloWorld&target=MDN");
    URLSearchParams:
      __additional:
        USVString: return true; // We already know this works, because we use a string to create the instance
        record: |-
          try {
            new URLSearchParams({"q": "HelloWorld", "target": "MDN"});
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
        sequence: |-
          try {
            new URLSearchParams([["q", "HelloWorld"], ["target", "MDN"]]);
            return true;
          } catch(e) {
            if (e instanceof TypeError) {
              return {result: false, message: e.message};
            }
            return e;
          }
    delete:
      __additional:
        value_parameter: |-
          instance = new URLSearchParams("foo=1&bar=2&foo=3&foo=1");
          instance.delete("foo", "1");
          return instance == "bar=2&foo=3";
    has:
      __additional:
        value_parameter: |-
          instance = new URLSearchParams("foo=1&bar=2&foo=3&foo=1");
          return instance.has("bar", "2") && !instance.has("bar", "3");
  ValidityState:
    __base: |-
      <%api.HTMLInputElement:el%>
      var instance = el.validity;
  VideoTrack:
    __resources:
      - video-blank
    __base: |-
      <%api.VideoTrackList:videoTracks%>
      var instance = videoTracks[0];
  VideoTrackList:
    __resources:
      - video-blank
    __base: |-
      var el = document.getElementById('resource-video-blank');
      var instance = el.videoTracks;
  VideoPlaybackQuality:
    __resources:
      - video-blank
    __base: |-
      var el = document.getElementById('resource-video-blank');
      var instance = el.getVideoPlaybackQuality();
  VRPose:
    __base: |-
      if (!('getVRDisplays' in navigator)) {
        return {result: false, message: 'WebVR 1.1 is not supported'};
      }
      // Obtaining an actual instance requires a VR headset to be hooked up,
      // so we are using the prototype instead
      var instance = VRPose.prototype;
  VTTCue:
    __resources:
      - video-blank
    __base: <%api.TextTrackCue:instance%>
  WaveShaperNode:
    __resources:
      - audioContext
    __base: |-
      if (!reusableInstances.audioContext) {
        return {result: false, message: 'Audio context is not available'};
      }
      if (!('createWaveShaper' in reusableInstances.audioContext)) {
        return {result: false, message: 'audioContext.createWaveShaper is not defined'};
      }
      var instance = reusableInstances.audioContext.createWaveShaper();
  WebGLContextEvent:
    __base: |-
      var instance;
      try {
        instance = new WebGLContextEvent('webglcontextlost');
      } catch(e) {
        if (!('document' in self)) {
          return {result: false, message: 'Cannot create event'};
        }
        try {
          instance = document.createEvent('WebGLContextEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  WebGLRenderingContext:
    __resources:
      - webGL1
    __base: var instance = reusableInstances.webGL1;
    makeXRCompatible: |-
      if (!('xr' in navigator)) {
        // Safari briefly exposes this when WebXR isn't implemented
        return {result: false, message: 'navigator.xr is not defined'};
      }
      return !!instance && 'makeXRCompatible' in instance;
  WebGL2RenderingContext:
    __resources:
      - webGL2
    __base: var instance = reusableInstances.webGL2;
  WEBGL_blend_equation_advanced_coherent:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_blend_equation_advanced_coherent');
  WEBGL_color_buffer_float:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('WEBGL_color_buffer_float');
  WEBGL_compressed_texture_astc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_astc');
  WEBGL_compressed_texture_atc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_atc');
  WEBGL_compressed_texture_etc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_etc');
  WEBGL_compressed_texture_etc1:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_etc1');
  WEBGL_compressed_texture_pvrtc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_pvrtc');
  WEBGL_compressed_texture_s3tc:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_s3tc');
  WEBGL_compressed_texture_s3tc_srgb:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_compressed_texture_s3tc_srgb');
  WEBGL_debug_renderer_info:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_debug_renderer_info');
  WEBGL_debug_shaders:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_debug_shaders');
  WEBGL_depth_texture:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('WEBGL_depth_texture');
  WEBGL_draw_buffers:
    __resources:
      - webGL1
    __base: |-
      if (!reusableInstances.webGL1) {
        return {result: false, message: 'WebGL 1 is not available'};
      };
      var instance = reusableInstances.webGL1.getExtension('WEBGL_draw_buffers');
  WEBGL_draw_instanced_base_vertex_base_instance:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_draw_instanced_base_vertex_base_instance');
  WEBGL_multi_draw:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_multi_draw');
  WEBGL_multi_draw_instanced_base_vertex_base_instance:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_multi_draw_instanced_base_vertex_base_instance');
  WEBGL_lose_context:
    __resources:
      - webGL
    __base: |-
      if (!reusableInstances.webGL) {
        return {result: false, message: 'WebGL is not available'};
      };
      var instance = reusableInstances.webGL.getExtension('WEBGL_lose_context');
  WebGLQuery:
    __resources:
      - webGL2
    __base: |-
      if (!reusableInstances.webGL2) {
        return {result: false, message: 'WebGL 2 is not available'};
      };
      if (!('createQuery' in reusableInstances.webGL2)) {
        return {result: false, message: 'WebGL2RenderingContext.createQuery() is not defined'};
      }
      var instance = reusableInstances.webGL2.createQuery();
  WebGLSampler:
    __resources:
      - webGL2
    __base: |-
      if (!reusableInstances.webGL2) {
        return {result: false, message: 'WebGL 2 is not available'};
      };
      if (!('createSampler' in reusableInstances.webGL2)) {
        return {result: false, message: 'WebGL2RenderingContext.createSampler() is not defined'};
      }
      var instance = reusableInstances.webGL2.createSampler();
  WebGLSync:
    __resources:
      - webGL2
    __base: |-
      if (!reusableInstances.webGL2) {
        return {result: false, message: 'WebGL 2 is not available'};
      };
      if (!('fenceSync' in reusableInstances.webGL2)) {
        return {result: false, message: 'WebGL2RenderingContext.fenceSync() is not defined'};
      }
      var instance = reusableInstances.webGL2.fenceSync(reusableInstances.webGL2.SYNC_GPU_COMMANDS_COMPLETE, 0);
  WebGLTimerQueryEXT:
    __resources:
      - webGL
    __base: |-
      <%api.EXT_disjoint_timer_query:ext%>
      var instance = ext.createQueryEXT();
  WebGLVertexArrayObjectOES:
    __resources:
      - webGL1
    __base: |-
      <%api.OES_vertex_array_object:ext%>
      var instance = ext.createVertexArrayOES();
  WebKitAnimationEvent:
    __base: |-
      var instance;
      try {
        instance = new WebKitAnimationEvent('webkitAnimationEnd');
      } catch(e) {
        try {
          instance = document.createEvent('WebKitAnimationEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  WebKitTransitionEvent:
    __base: |-
      var instance;
      try {
        instance = new WebKitTransitionEvent('webkitTransitionEnd');
      } catch(e) {
        try {
          instance = document.createEvent('WebKitTransitionEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  WebSocket:
    __base: |-
      var constructor = self.WebSocket || self.MozWebSocket;
      if (!constructor) {
        return {result: false, message: '(Moz)WebSocket is not defined or falsy'};
      }
      var instance = new constructor('wss://' + location.hostname);
      bcd.addCleanup(function() {
        instance.close();
      });
  WheelEvent:
    __base: |-
      var instance;
      try {
        instance = new WheelEvent('wheel');
      } catch(e) {
        try {
          instance = document.createEvent('WheelEvent');
        } catch(e) {
          if (e.name === 'NotSupportedError' || e.name === 'NOT_SUPPORTED_ERR') {
            return {result: false, message: 'Cannot create event'};
          }
          throw e;
        }
      }
  Window:
    __base: var instance = window;
    scroll:
      __additional:
        options_behavior_parameter: return bcd.testOptionParam(instance, 'scroll', 'behavior', 'auto');
        options_left_parameter: return bcd.testOptionParam(instance, 'scroll', 'left', '0');
        options_top_parameter: return bcd.testOptionParam(instance, 'scroll', 'top', '0');
    scrollBy:
      __additional:
        options_behavior_parameter: return bcd.testOptionParam(instance, 'scrollBy', 'behavior', 'auto');
        options_left_parameter: return bcd.testOptionParam(instance, 'scrollBy', 'left', '0');
        options_top_parameter: return bcd.testOptionParam(instance, 'scrollBy', 'top', '0');
    scrollTo:
      __additional:
        options_behavior_parameter: return bcd.testOptionParam(instance, 'scrollTo', 'behavior', 'auto');
        options_left_parameter: return bcd.testOptionParam(instance, 'scrollTo', 'left', '0');
        options_top_parameter: return bcd.testOptionParam(instance, 'scrollTo', 'top', '0');
  WorkerGlobalScope:
    __base: var instance = self;
  WorkerLocation:
    __base: var instance = location;
    toString: |-
      if (!('toString' in instance)) {
        return {result: false, message: 'toString is not defined'};
      }
      return instance.toString() == instance.href;
  WorkerNavigator:
    __base: var instance = navigator;
  Worklet:
    __resources:
      - audioContext
    __base: |-
      var instance;
      if (reusableInstances.audioContext) {
        instance = reusableInstances.audioContext.audioWorklet;
      } else {
        instance = CSS.paintWorklet;
      }
  WritableStreamDefaultController:
    __base: |-
      if (!('WritableStream' in self)) {
        return {result: false, message: 'WritableStream is not defined'};
      };
      var promise = new Promise(function(resolve, reject) {
        new WritableStream({
          start(controller) {
            resolve(controller)
          }
        })
      });
  WritableStreamDefaultWriter:
    __base: |-
      if (!('WritableStream' in self)) {
        return {result: false, message: 'WritableStream is not defined'};
      };
      var instance = new WritableStream({}).getWriter();
  XMLHttpRequest:
    __base: |-
      if (!('XMLHttpRequest' in self)) {
        return {result: false, message: 'XMLHttpRequest is not defined'};
      }
      var instance = new XMLHttpRequest();
    responseType:
      __additional:
        arraybuffer_value: |-
          instance.responseType = 'arraybuffer';
          return instance.responseType === 'arraybuffer';
        blob_value: |-
          instance.responseType = 'blob';
          return instance.responseType === 'blob';
        document_value: |-
          instance.responseType = 'document';
          return instance.responseType === 'document';
        json_value: |-
          instance.responseType = 'json';
          return instance.responseType === 'json';
  XMLHttpRequestEventTarget:
    __base: <%api.XMLHttpRequest:instance%>
  XMLHttpRequestUpload:
    __base: |-
      <%api.XMLHttpRequest:xhr%>
      var instance = xhr.upload;
  XPathExpression:
    __base: |-
      var xpe = new XPathEvaluator();
      var instance = xpe.createExpression('//div', xpe.createNSResolver(document));
  XPathResult:
    __base: |-
      <%api.XPathExpression:exp%>
      var instance = exp.evaluate(document, 0, null);
  XRSystem:
    __base: var instance = navigator.xr;

# Features defined here also need to be in @webref/css or custom/css.json.
css:
  properties:
    custom-property:
      __test: return CSS.supports('color', 'var(--foo)') || CSS.supports('color', 'env(--foo)');
      __additional:
        var: return CSS.supports('color', 'var(--foo)');
        env: return CSS.supports('color', 'env(--foo)');
    aspect-ratio: |-
      return bcd.testCSSProperty('aspect-ratio', '16 / 9');
  selectors:
    next-sibling: return bcd.testCSSSelector('div + span');
    child: return bcd.testCSSSelector('div > span');
    column: return bcd.testCSSSelector('div || span');
    subsequent-sibling: return bcd.testCSSSelector('div ~ span');
    cue: return bcd.testCSSSelector('video::cue');
    highlight: return bcd.testCSSSelector('::highlight(rainbow-color-1)');
    part: return bcd.testCSSSelector('::part(tab)');
    slotted: return bcd.testCSSSelector('::slotted(*)');
    view-transition-group: return bcd.testCSSSelector('::view-transition-group(*)');
    view-transition-image-pair: return bcd.testCSSSelector('::view-transition-image-pair(*)');
    view-transition-new: return bcd.testCSSSelector('::view-transition-new(*)');
    view-transition-old: return bcd.testCSSSelector('::view-transition-old(*)');
    active-view-transition: return bcd.testCSSSelector(':root:active-view-transition(*)');
    dir: return bcd.testCSSSelector(':dir(ltr)');
    has: return bcd.testCSSSelector(':has(+ *)');
    host: return bcd.testCSSSelector(':host(h1)');
    host-context: return bcd.testCSSSelector(':host-context(h1)');
    is: return bcd.testCSSSelector(':is(h1)');
    lang: return bcd.testCSSSelector(':lang(en-US)');
    list: "return {result: null, message: 'Testing list selector is not yet implemented'};"
    not: return bcd.testCSSSelector(':not(strong)');
    nth-child: return bcd.testCSSSelector(':nth-child(even)');
    nth-last-child: return bcd.testCSSSelector(':nth-last-child(even)');
    nth-last-of-type: return bcd.testCSSSelector(':nth-last-of-type(even)');
    nth-of-type: return bcd.testCSSSelector(':nth-of-type(even)');
    where: return bcd.testCSSSelector(':where(ol, ul)');
    first: "return {result: null, message: 'Testing :first is not yet implemented'};"
    left: "return {result: null, message: 'Testing :left is not yet implemented'};"
    right: "return {result: null, message: 'Testing :right is not yet implemented'};"

html:
  # Features defined here also need to be in @webref/elements or custom/elements.json.
  elements:
    input:
      __base: |-
        var instance = document.createElement('input');
        function testType(type) {
          instance.type = type;
          return instance.type === type;
        }
      __additional:
        type_button: return testType('button');
        type_checkbox: return testType('checkbox');
        type_color: return testType('color');
        type_date: return testType('date');
        type_datetime-local: return testType('datetime-local');
        type_email: return testType('email');
        type_file: return testType('file');
        type_hidden: return testType('hidden');
        type_image: return testType('image');
        type_month: return testType('month');
        type_number: return testType('number');
        type_password: return testType('password');
        type_radio: return testType('radio');
        type_range: return testType('range');
        type_reset: return testType('reset');
        type_search: return testType('search');
        type_submit: return testType('submit');
        type_tel: return testType('tel');
        type_text: return testType('text');
        type_time: return testType('time');
        type_url: return testType('url');
        type_week: return testType('week');

mathml:
  # Features defined here also need to be in @webref/elements or custom/elements.json.
  # Most test code here is based on https://github.com/web-platform-tests/wpt/blob/master/mathml/support/feature-detection.js
  elements:
    annotation: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    annotation-xml: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    maction: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    math: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    menclose: |-
      // Just check whether <mrow> is supported because discussion on this is
      // still open (https://github.com/mathml-refresh/mathml/issues/105 
      // and it would have to behave at least like an mrow, even if it becomes
      // an unknown element at the end.
      <%mathml.elements.mrow:instance%>
      return has_mspace;
    merror: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mfenced: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mfrac:
      __base: |-
        // Use tall enough fraction to avoid side effect of min num/denum shifts.
        var mathEl = document.createElementNS("http://www.w3.org/1998/Math/MathML", "math");
        mathEl.innerHTML = "<mfrac><mspace height='50px' depth='50px'></mspace><mspace height='50px' depth='50px'></mspace></mfrac><mfrac><mspace height='60px' depth='60px'></mspace><mspace height='60px' depth='60px'></mspace></mfrac>";
        document.getElementById('resources').appendChild(mathEl);
        bcd.addCleanup(function() {
          document.getElementById('resources').removeChild(mathEl);
        });

        var mfrac = mathEl.getElementsByTagName("mfrac");
        // height/depth will add 40px per MathML, 20px if mfrac does not stack its children and none if mspace is not supported.
        var has_mfrac = mfrac[1].getBoundingClientRect().height - mfrac[0].getBoundingClientRect().height > 30;
      __test: return has_mfrac;
    mi: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mmultiscripts: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mn: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mo: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mover: |-
      // XXX Improve feature detection
      <%mathml.elements.munderover:instance%>
      return has_munderover;
    mpadded: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mphantom: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mprescripts: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mroot: |-
      // XXX Improve feature detection
      <%mathml.elements.msqrt:instance%>
      return has_msqrt;
    mrow:
      __base: |-
        // XXX Improve feature detection
        <%mathml.elements.mspace:instance%>
      __test: return has_mspace;
    ms: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mspace:
      __base: |-
        var mathEl = document.createElementNS("http://www.w3.org/1998/Math/MathML", "math");
        mathEl.innerHTML = "<mspace></mspace><mspace width='20px'></mspace>";
        document.getElementById('resources').appendChild(mathEl);
        bcd.addCleanup(function() {
          document.getElementById('resources').removeChild(mathEl);
        });

        // The width attribute will add 20px per MathML and none if not supported.
        var has_mspace = mathEl.lastChild.getBoundingClientRect().width - mathEl.firstChild.getBoundingClientRect().width > 10;
      __test: return has_mspace;
    msqrt:
      __base: |-
        var mathEl = document.createElementNS("http://www.w3.org/1998/Math/MathML", "math");
        mathEl.innerHTML = "<mrow style='font-size: 20px !important'><mtext>A</mtext></mrow><msqrt style='font-size: 20px !important'><mtext>A</mtext></msqrt>";
        document.getElementById('resources').appendChild(mathEl);
        bcd.addCleanup(function() {
          document.getElementById('resources').removeChild(mathEl);
        });

        // The radical symbol will make msqrt wider than mrow, if the former is supported.
        var has_msqrt = mathEl.lastElementChild.getBoundingClientRect().width - mathEl.firstElementChild.getBoundingClientRect().width > 5;
      __test: return has_msqrt;
    mstyle: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    msub: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    msubsup: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    msup: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mtable: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mtd: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mtext: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    mtr: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;
    munder: |-
      // XXX Improve feature detection
      <%mathml.elements.munderover:instance%>
      return has_munderover;
    munderover:
      __base: |-
        var mathEl = document.createElementNS("http://www.w3.org/1998/Math/MathML", "math");
        mathEl.innerHTML = "<munderover><mspace width='20px'></mspace><mspace width='20px'></mspace><mspace width='20px'></mspace></munderover><munderover><mspace width='40px'></mspace><mspace width='40px'></mspace><mspace width='40px'></mspace></munderover>";
        document.getElementById('resources').appendChild(mathEl);
        bcd.addCleanup(function() {
          document.getElementById('resources').removeChild(mathEl);
        });

        var munderover = mathEl.getElementsByTagName("munderover");
        // width_delta will be 20px per MathML, 3 * 20 = 60px if mundeover does not stack its children and 0px if mspace is not supported.
        var width_delta = munderover[1].getBoundingClientRect().width - munderover[0].getBoundingClientRect().width;
        var has_munderover = width_delta > 10 && width_delta < 30;
      __test: return has_munderover;
    semantics: |-
      // XXX Improve feature detection
      <%mathml.elements.mspace:instance%>
      return has_mspace;

# Features defined here also need to be in custom/js.json.
javascript:
  builtins:
    AggregateError:
      __base: |-
        if (!('AggregateError' in self)) {
          return {result: false, message: 'AggregateError is not defined'};
        }
        var instance = new AggregateError(
          // An iterable of errors
          new Set([new Error("some error"), new Error("another error")]),
          "Multiple errors thrown",
        );
      AggregateError: return !!instance;
    ArrayBuffer:
      ArrayBuffer:
        __additional:
          maxByteLength_option: function construct(options) {
            new ArrayBuffer(8, options);
            }
            return bcd.testOptionParam(construct, null, 'maxByteLength', 16);
    AsyncFunction:
      __base: |-
        var func;
        var instance;
        try {
          func = async function(){
            return true;
          };

          instance = func();
        } catch(e) {
          if (e instanceof TypeError) {
            return {result: false, message: e.message};
          }
          throw e;
        }
      AsyncFunction: |-
        var AsyncFunction = func.constructor;
        if (!AsyncFunction) {
          return false;
        }
        try {
          new AsyncFunction('return true');
          return true;
        } catch(e) {
          return {result: false, message: e.message};
        }
    AsyncGenerator:
      __base: <%javascript.builtins.AsyncGeneratorFunction:instance%>
    AsyncGeneratorFunction:
      __base: |-
        var func;
        var instance;
        try {
          func = async function *(){
            yield true;
          };

          instance = func();
        } catch(e) {
          if (e instanceof TypeError) {
            return {result: false, message: e.message};
          }
          throw e;
        }
      AsyncGeneratorFunction: |-
        var AsyncGeneratorFunction = func.constructor;
        if (!AsyncGeneratorFunction) {
          return false;
        }
        try {
          new AsyncGeneratorFunction('yield true');
          return true;
        } catch(e) {
          return false;
        }
    AsyncIterator:
      __base: <%javascript.builtins.AsyncGeneratorFunction:instance%>
      "@@asyncIterator": |-
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(instance)));
        return !!instance && "Symbol" in self && "asyncIterator" in Symbol && Symbol.asyncIterator in AsyncIteratorPrototype;
    DataView:
      DataView:
        __additional:
          sharedarraybuffer_support: |-
            if (!('SharedArrayBuffer' in self)) {
              return {result: false, message: 'SharedArrayBuffer is not defined'};
            }
            var sab = new SharedArrayBuffer(1024);

            try {
              var instance = new DataView(sab, 0);
              return true;
            } catch(e) {
              return {result: false, message: e.message};
            }
    Date:
      UTC:
        __additional:
          optional_monthIndex: |-
            try {
              Date.UTC(2024);
              return {result: true, message: 'Method passed without monthIndex parameter'};
            } catch(e) {
              return {result: false, message: e.message};
            }
    Error:
      __base: "var instance = new Error('hello world', {cause: 'for testing'});"
      Error:
        __additional:
          fileName_parameter: |-
            var e = new Error('foo', 'bar.js');
            return e.fileName === 'bar.js';
          lineNumber_parameter: |-
            var e = new Error('foo', 'bar.js', 420);
            return e.lineNumber === 420;
          options_cause_parameter: |-
            var e = new Error('foo', {cause: 'testing'});
            return e.cause === 'testing';
    Float32Array:
      __additional:
        Float32Array.iterable_allowed: |-
          <%javascript.builtins.GeneratorFunction:iterable%>
          try {
            new Float32Array(iterable);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    Float64Array:
      __additional:
        Float64Array.iterable_allowed: |-
          <%javascript.builtins.GeneratorFunction:iterable%>
          try {
            new Float64Array(iterable);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    Function:
      name: |-
        function doTheThing() {};
        return doTheThing.name == 'doTheThing';
    Generator:
      __base: <%javascript.builtins.GeneratorFunction:instance%>
      __test: return !!instance;
    GeneratorFunction:
      __base: |-
        var instance;
        try {
          function *a(){
            yield true;
          };

          instance = a();
        } catch(e) {
          if (e instanceof TypeError) {
            return {result: false, message: e.message};
          }
          throw e;
        }
      __test: return !!instance;
      GeneratorFunction: return !!instance;
    Int16Array:
      __additional:
        Int16Array.iterable_allowed: |-
          <%javascript.builtins.GeneratorFunction:iterable%>
          try {
            new Int16Array(iterable);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    Int32Array:
      __additional:
        Int32Array.iterable_allowed: |-
          <%javascript.builtins.GeneratorFunction:iterable%>
          try {
            new Int32Array(iterable);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    Int8Array:
      __additional:
        Int8Array.iterable_allowed: |-
          <%javascript.builtins.GeneratorFunction:iterable%>
          try {
            new Int8Array(iterable);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    Intl:
      Collator:
        Collator:
          __base: |-
            if (!("Intl" in self)) {
              return { result: false, message: "Intl is not defined" };
            }
            if (!("Collator" in Intl)) {
              return { result: false, message: "Intl.Collator is not defined" };
            }

            function construct(options) {
              new Intl.Collator('en', options);
            }
          __additional:
            options_caseFirst_parameter: return bcd.testOptionParam(construct, null, 'caseFirst', 'upper');
            options_collation_parameter: return bcd.testOptionParam(construct, null, 'collation', 'default');
      DateTimeFormat:
        DateTimeFormat:
          __base: |-
            if (!("Intl" in self)) {
              return { result: false, message: "Intl is not defined" };
            }
            if (!("DateTimeFormat" in Intl)) {
              return { result: false, message: "Intl.DateTimeFormat is not defined" };
            }

            function construct(options) {
              new Intl.DateTimeFormat('en', options);
            }
          __additional:
            locales_parameter: |-
              var instance = new Intl.DateTimeFormat('de');
              var options = instance.resolvedOptions();
              return options.locale === 'de';
            options_parameter: |-
              // The timeZone parameter was one of the first options available
              return bcd.testOptionParam(construct, null, 'timeZone', 'UTC');
            options_parameter.options_calendar_parameter: return bcd.testOptionParam(construct, null, 'calendar', 'chinese');
            options_parameter.options_dateStyle_parameter: return bcd.testOptionParam(construct, null, 'dateStyle', 'full');
            options_parameter.options_dayPeriod_parameter: return bcd.testOptionParam(construct, null, 'dayPeriod', 'narrow');
            options_parameter.options_fractionalSecondDigits_parameter: return bcd.testOptionParam(construct, null, 'fractionalSecondDigits', 2);
            options_parameter.options_hourCycle_parameter: return bcd.testOptionParam(construct, null, 'hourCycle', 'h23');
            options_parameter.options_numberingSystem_parameter: return bcd.testOptionParam(construct, null, 'numberingSystem', 'hans');
            options_parameter.options_timeStyle_parameter: return bcd.testOptionParam(construct, null, 'timeStyle', 'full');
            options_parameter.options_timeZone_parameter: return bcd.testOptionParam(construct, null, 'timeZone', 'UTC');
            options_parameter.options_timeZone_parameter.iana_time_zones: return bcd.testOptionParam(construct, null, 'timeZone', 'Asia/Shanghai');
            options_parameter.options_timeZoneName_parameter: return bcd.testOptionParam(construct, null, 'timeZoneName', 'long');
            options_parameter.options_timeZoneName_parameter.extended_values: return bcd.testOptionParam(construct, null, 'timeZoneName', 'shortGeneric');
      NumberFormat:
        NumberFormat:
          __base: |-
            if (!("Intl" in self)) {
              return { result: false, message: "Intl is not defined" };
            }
            if (!("NumberFormat" in Intl)) {
              return { result: false, message: "Intl.NumberFormat is not defined" };
            }

            function construct(options) {
              new Intl.NumberFormat('en', options);
            }
          __additional:
            locales_parameter: |-
              var instance = new Intl.NumberFormat('de');
              var options = instance.resolvedOptions();
              return options.locale === 'de';
            options_parameter: |-
              // The style parameter was one of the first options available
              return bcd.testOptionParam(construct, null, 'style', 'currency');
            options_parameter.options_compactDisplay_parameter: "return bcd.testOptionParam(construct, null, 'compactDisplay', 'long', {'notation': 'compact'});"
            options_parameter.options_currency_parameter: return bcd.testOptionParam(construct, null, 'currency', 'USD');
            options_parameter.options_currencyDisplay_parameter: return bcd.testOptionParam(construct, null, 'currencyDisplay', 'name');
            options_parameter.options_currencySign_parameter: return bcd.testOptionParam(construct, null, 'currencySign', 'accounting');
            options_parameter.options_localeMatcher_parameter: return bcd.testOptionParam(construct, null, 'localeMatcher', 'lookup');
            options_parameter.options_maximumFractionDigits_parameter: return bcd.testOptionParam(construct, null, 'maximumFractionDigits', 10);
            options_parameter.options_maximumSignificantDigits_parameter: return bcd.testOptionParam(construct, null, 'maximumSignificantDigits', 10);
            options_parameter.options_minimumFractionDigits_parameter: return bcd.testOptionParam(construct, null, 'minimumFractionDigits', 10);
            options_parameter.options_minimumIntegerDigits_parameter: return bcd.testOptionParam(construct, null, 'minimumIntegerDigits', 10);
            options_parameter.options_minimumSignificantDigits_parameter: return bcd.testOptionParam(construct, null, 'minimumSignificantDigits', 10);
            options_parameter.options_notation_parameter: return bcd.testOptionParam(construct, null, 'notation', 'compact');
            options_parameter.options_numberingSystem_parameter: return bcd.testOptionParam(construct, null, 'numberingSystem', 'hans');
            options_parameter.options_roundingIncrement_parameter: return bcd.testOptionParam(construct, null, 'roundingIncrement', 200);
            options_parameter.options_roundingMode_parameter: return bcd.testOptionParam(construct, null, 'roundingMode', 'floor');
            options_parameter.options_roundingPriority_parameter: return bcd.testOptionParam(construct, null, 'roundingPriority', 'lessPrecision');
            options_parameter.options_signDisplay_parameter: return bcd.testOptionParam(construct, null, 'signDisplay', 'always');
            options_parameter.options_signDisplay_parameter.negative: |-
              var instance = Intl.NumberFormat('en', {signDisplay: 'negative'});
              var options = instance.resolvedOptions();
              return options.signDisplay === 'negative';
            options_parameter.options_style_parameter: return bcd.testOptionParam(construct, null, 'style', 'currency');
            options_parameter.options_trailingZeroDisplay_parameter: return bcd.testOptionParam(construct, null, 'trailingZeroDisplay', 'currency');
            options_parameter.options_unit_parameter: return bcd.testOptionParam(construct, null, 'unit', 'gigabyte');
            options_parameter.options_unitDisplay_parameter: "return bcd.testOptionParam(construct, null, 'unitDisplay', 'narrow', {unit: 'gigabyte'});"
            options_parameter.options_useGrouping_parameter: return bcd.testOptionParam(construct, null, 'useGrouping', false);
            options_parameter.options_useGrouping_parameter.string_values: |-
              var instance = Intl.NumberFormat('en', {useGrouping: 'always'});
              var options = instance.resolvedOptions();
              return options.useGrouping === 'always';
      PluralRules:
        PluralRules:
          __base: |-
            if (!("Intl" in self)) {
              return { result: false, message: "Intl is not defined" };
            }
            if (!("PluralRules" in Intl)) {
              return { result: false, message: "Intl.PluralRules is not defined" };
            }

            function construct(options) {
              new Intl.PluralRules('en', options);
            }
          __additional:
            options_parameter: |-
              // The roundingIncrement parameter was one of the first options available
              return bcd.testOptionParam(construct, null, 'roundingIncrement', 200);
            options_parameter.options_roundingIncrement_parameter: return bcd.testOptionParam(construct, null, 'roundingIncrement', 200);
            options_parameter.options_roundingMode_parameter: return bcd.testOptionParam(construct, null, 'roundingMode', 'floor');
            options_parameter.options_roundingPriority_parameter: return bcd.testOptionParam(construct, null, 'roundingPriority', 'lessPrecision');
            options_parameter.options_trailingZeroDisplay_parameter: return bcd.testOptionParam(construct, null, 'trailingZeroDisplay', 'currency');
      RelativeTimeFormat:
        RelativeTimeFormat:
          __base: |-
            if (!("Intl" in self)) {
              return { result: false, message: "Intl is not defined" };
            }
            if (!("RelativeTimeFormat" in Intl)) {
              return { result: false, message: "Intl.RelativeTimeFormat is not defined" };
            }

            function construct(options) {
              new Intl.RelativeTimeFormat('en', options);
            }
          __additional:
            locales_parameter: |-
              var instance = new Intl.RelativeTimeFormat('de');
              var options = instance.resolvedOptions();
              return options.locale === 'de';
            options_parameter: |-
              // The style parameter was one of the first options available
              return bcd.testOptionParam(construct, null, 'style', 'currency');
            options_parameter.options_localeMatcher_parameter: return bcd.testOptionParam(construct, null, 'localeMatcher', 'lookup');
            options_parameter.options_numberingSystem_parameter: return bcd.testOptionParam(construct, null, 'numberingSystem', 'hans');
            options_parameter.options_numeric_parameter: return bcd.testOptionParam(construct, null, 'numeric', 'auto');
            options_parameter.options_style_parameter: return bcd.testOptionParam(construct, null, 'style', 'currency');
      Segments:
        __base: |-
          if (!('Intl' in self && 'Segmenter' in Intl)) {
            return {result: false, message: 'Intl.Segmenter is not defined'};
          }
          var segmenter = new Intl.Segmenter('fr', { granularity: 'word' });
          var instance = segmenter.segment('Que ma joie demeure');
    Iterator:
      __base: |-
        var array = [1, 2, 3];
        if (!('values' in array)) {
          return {result: false, message: "Array.prototype.values is not defined"};
        }
        var instance = array.values();
      "@@iterator": return !!instance && "Symbol" in self && "iterator" in Symbol && !!(instance[Symbol.iterator]);
    Map:
      __additional:
        Map.iterable_allowed: |-
          try {
            new Map([
              [1, "one"],
              [2, "two"],
              [3, "three"],
            ]);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
        Map.null_allowed: |-
          try {
            new Map(null);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    Object:
      defineGetter: return '__defineGetter__' in {};
      defineSetter: return '__defineSetter__' in {};
      lookupGetter: return '__lookupGetter__' in {};
      lookupSetter: return '__lookupSetter__' in {};
      proto: return '__proto__' in {};
      __additional:
        constructor: |-
          var instance = {};
          return !!instance.constructor;
    RegExp:
      __base: |-
        if (!('RegExp' in self)) {
          return {result: false, message: 'RegExp is not defined'};
        }
        var instance = new RegExp('foo', 'g');
      n: return '$1' in RegExp;
    Set:
      __additional:
        Set.iterable_allowed: |-
          try {
            new Set([1, 2, 3, 4, 5]);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
        Set.null_allowed: |-
          try {
            new Set(null);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    TypedArray:
      __base: |-
        if (!('Int8Array' in self)) {
          return {result: false, message: 'Int8Array is not defined'};
        }
        var instance = new Int8Array(2);
      TypedArray: return !!instance;
      from: return 'from' in Int8Array;
      name: return 'name' in Int8Array;
      of: return 'of' in Int8Array;
      "@@species": return "Symbol" in self && "species" in Symbol && !!Int8Array[Symbol.species];
      __additional:
        constructor_without_parameters: |-
          try {
            new Int8Array();
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
        iterable_in_constructor: |-
          <%javascript.builtins.GeneratorFunction:iterable%>
          try {
            new Int8Array(iterable);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
        new_required: |-
          try {
            Int8Array();
            return false;
          } catch(e) {
            return {result: true, message: e.message};
          }
    Uint16Array:
      __additional:
        Uint16Array.iterable_allowed: |-
          <%javascript.builtins.GeneratorFunction:iterable%>
          try {
            new Uint16Array(iterable);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    Uint32Array:
      __additional:
        Uint32Array.iterable_allowed: |-
          <%javascript.builtins.GeneratorFunction:iterable%>
          try {
            new Uint32Array(iterable);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    Uint8Array:
      __additional:
        Uint8Array.iterable_allowed: |-
          <%javascript.builtins.GeneratorFunction:iterable%>
          try {
            new Uint8Array(iterable);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    Uint8ClampedArray:
      __additional:
        Uint8ClampedArray.iterable_allowed: |-
          <%javascript.builtins.GeneratorFunction:iterable%>
          try {
            new Uint8ClampedArray(iterable);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    WeakMap:
      __additional:
        WeakMap.iterable_allowed: |-
          try {
            new WeakMap([
              [window, "one"],
              [{}, "two"],
            ]);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
        WeakMap.null_allowed: |-
          try {
            new WeakMap(null);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
    WeakSet:
      __additional:
        WeakSet.iterable_allowed: |-
          try {
            new WeakSet([window, {}]);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }
        WeakSet.null_allowed: |-
          try {
            new WeakSet(null);
            return true;
          } catch(e) {
            return {result: false, message: e.message};
          }

# Features defined here also need to be in test-builder/webassembly.ts.
webassembly:
  # Features defined here also need to be in https://webassembly.github.io/spec/web-api/index.html or custom/idl/webassembly.idl.
  api:
    Exception:
      stack: |-
        if (!('WebAssembly' in self && 'Exception' in WebAssembly)) {
          return {result: false, message: 'WebAssembly.Exception is not defined'};
        }
        var instance = new WebAssembly.Exception(
          new WebAssembly.Tag({parameters: ["i32", "i64"]}),
          ["i32", BigInt(64)],
          {traceStack: true}
        );
        return !!instance && "stack" in instance;
